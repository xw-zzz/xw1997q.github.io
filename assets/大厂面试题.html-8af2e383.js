import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c as d,a as n,e as a,d as i,b as e}from"./app-ec12a113.js";const c="/assets/image-20240408170911471-312eccb6.png",l="/assets/sync_1-b7ec991e.png",h="/assets/lock-a5478660.png",p="/assets/20220626215843-3c428eca.png",u="/assets/mysql查询流程-b1b51a70.png",b="/assets/mysql连接错误-ccf15555.png",g="/assets/密码错误-ed9b0e50.png",m="/assets/查看连接-d4f23545.png",k={},y=e(`<h1 id="大厂面试题" tabindex="-1"><a class="header-anchor" href="#大厂面试题" aria-hidden="true">#</a> 大厂面试题</h1><h2 id="阿里二面——jvm-什么是类加载机制" tabindex="-1"><a class="header-anchor" href="#阿里二面——jvm-什么是类加载机制" aria-hidden="true">#</a> 阿里二面——JVM：什么是类加载机制</h2><p>类加载机制是Java虚拟机（JVM）的重要组成部分，它负责在运行时动态加载Java类并将类信息转化为可在JVM内部使用的运行时数据结构。类加载过程主要包含以下几个核心环节：</p><ol><li><strong>加载</strong>（Loading）： <ul><li>JVM通过类加载器（ClassLoader）找到.class文件，并读取其二进制数据。</li><li>将这些数据加载到JVM内存的方法区内，创建方法区内的运行时类数据结构。</li><li>在堆内存中为这个类创建一个java.lang.Class对象，作为方法区类数据的外部入口。</li></ul></li><li><strong>验证</strong>（Verification）： <ul><li>确保加载的类信息符合Java虚拟机规范，没有安全方面的威胁，比如非法数据、不符合语义的字节码指令等。</li></ul></li><li><strong>准备</strong>（Preparation）： <ul><li>分配类变量（静态变量）所需的内存空间，并且默认初始化为零值。</li></ul></li><li><strong>解析</strong>（Resolution）： <ul><li>将符号引用转换为直接引用，比如将类引用、字段引用、方法引用转换为实际内存地址。</li></ul></li><li><strong>初始化</strong>（Initialization）： <ul><li>执行类初始化的clinit()方法，初始化静态变量并执行静态初始化块，此时真正的初始值被赋予静态变量。</li></ul></li><li><strong>类加载器及其委托模型</strong>： <ul><li>JVM使用多层级的类加载器体系，其中最核心的是双亲委派模型。当一个类加载器收到加载请求时，首先委托父加载器加载，直到顶层启动类加载器。只有当父加载器无法加载时，子加载器才会尝试自己加载。</li></ul></li><li><strong>按需加载</strong>（Lazy Loading）： <ul><li>类的加载并非一次性全部加载，而是按需加载，也就是在首次使用该类时才会触发加载动作。</li></ul></li><li><strong>缓存机制</strong>： <ul><li>已加载过的类会被存储在缓存中，避免重复加载，提高性能。</li></ul></li></ol><h2 id="阿里二面——多线程-线程池处理任务时-出现异常会发生什么" tabindex="-1"><a class="header-anchor" href="#阿里二面——多线程-线程池处理任务时-出现异常会发生什么" aria-hidden="true">#</a> 阿里二面——多线程：线程池处理任务时，出现异常会发生什么？</h2><p>在Java中，线程池是一种用于管理和复用线程的机制。当线程池执行任务时，如果任务发生异常，会有不同的处理方式，具体取决于你如何配置和处理异常。</p><p>当线程池中的线程执行任务时，如果任务抛出未捕获的异常，这个异常会传递给线程池的异常处理器(Thread.UncaughtExceptionHandler)。异常处理器是一个接口，可以自定义实现。如果没有显式地设置异常处理器，则会使用默认的处理器来处理异常。</p><p>**默认的异常处理器会打印异常堆栈跟踪信息，并终止抛出异常的线程。如果线程是由线程池创建的，线程池会注意到线程终止并从池中移除该线程，然后创建一个新的线程来替代它，以保持线程池中的线程数量不变。**以一段代码示例如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个固定大小为2的线程池</span>
        <span class="token class-name">ExecutorService</span> threadPoolExecutor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 提交第一个任务到线程池执行</span>
        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程ID&quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 提交第二个任务到线程池执行</span>
        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程ID&quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 提交第三个任务到线程池执行，此任务试图进行除以0的操作，会抛出异常</span>
        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程ID&quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 暂停2秒，以便观察线程执行情况</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 继续提交任务到线程池，此时线程池可能仍在处理前三个任务</span>
        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程ID&quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程ID&quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 程序暂停100000秒，主要用于测试和观察，实际应用中可能需要根据情况调整</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下所示，</p><p><img src="`+c+`" alt="image-20240408170911471" loading="lazy"></p><p>为了处理线程池中任务的异常，我们可以采取以下步骤：</p><h3 id="_1-自定义异常处理器" tabindex="-1"><a class="header-anchor" href="#_1-自定义异常处理器" aria-hidden="true">#</a> 1.自定义异常处理器</h3><p>实现Thread.UncaughtExceptionHandler接口，并重写uncaughtException()方法来定义你自己的异常处理逻辑。例如，你可以记录异常日志、发送警报或采取其他适当的操作。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomExceptionHandler</span> <span class="token keyword">implements</span> <span class="token class-name">Thread<span class="token punctuation">.</span>UncaughtExceptionHandler</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">uncaughtException</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 自定义异常处理逻辑</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Exception occurred in thread: &quot;</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 其他处理操作...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-在创建线程池时设置异常处理器" tabindex="-1"><a class="header-anchor" href="#_2-在创建线程池时设置异常处理器" aria-hidden="true">#</a> 2.在创建线程池时设置异常处理器</h3><p>在创建线程池时，使用ThreadPoolExecutor的构造函数之一，并传递自定义的异常处理器。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Thread<span class="token punctuation">.</span>UncaughtExceptionHandler</span> exceptionHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomExceptionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
    corePoolSize<span class="token punctuation">,</span> maxPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exceptionHandler
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，当线程池中的线程执行任务时发生异常，就会调用自定义的异常处理器进行处理。</p><h3 id="_3-在任务的执行体中捕获异常" tabindex="-1"><a class="header-anchor" href="#_3-在任务的执行体中捕获异常" aria-hidden="true">#</a> 3.在任务的执行体中捕获异常</h3><p>如果我们的任务实现了Runnable接口或Callable接口，我们可以在任务的run()或call()方法中使用try-catch块来捕获异常，并在捕获到异常后进行适当的处理。这种方式可以防止异常传播到线程池的异常处理器中。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Runnable</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 任务执行代码</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 异常处理逻辑</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 其他处理操作...</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上述方式，我们可以自定义处理线程池中任务抛出的异常。这样可以确保我们对异常有完全的控制，并能采取适当的操作，如记录日志、处理错误、发送通知等。</p><h2 id="阿里二面——多线程-concurrenthashmap的红黑树中为何会保留一套双向链表" tabindex="-1"><a class="header-anchor" href="#阿里二面——多线程-concurrenthashmap的红黑树中为何会保留一套双向链表" aria-hidden="true">#</a> 阿里二面——多线程：ConcurrentHashMap的红黑树中为何会保留一套双向链表？</h2><h2 id="阿里二面——多线程-聊一下concurrenthashmap的扩容是怎么做的" tabindex="-1"><a class="header-anchor" href="#阿里二面——多线程-聊一下concurrenthashmap的扩容是怎么做的" aria-hidden="true">#</a> 阿里二面——多线程：聊一下ConcurrentHashMap的扩容是怎么做的？</h2><p>table数据转移到nextTable。扩容操作的核心在于数据的转移，把旧数组中的数据迁移到新的 数组。ConcurrentHashMap精华的部分是它可以利用多线程进行协同扩容，简单来说，它把table数 组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程锁负责的区间，每个 线程通过区间逆向遍历来实现扩容，一个已经迁移完的Bucket会被替换为一个ForwardingNode节点， 标记当前Bucket已经被其他线程迁移完了。 （5）helpTransfer() ConcurrentHashMap鬼斧神工，并发添加元素时，如果正在扩容，其他线程会帮助扩容，也就 是多线程扩容。 第一次添加元素时，默认初期长度为16，当往table中继续添加元素时，通过哈希值跟数组长 度取余来决定放在数组的哪个Bucket位置，如果出现放在同一个位置时，就优先以链表的形式存放， 在同一个位置的个数又达到了8个以上，如果数组的长度还小于64时，就会扩容数组。如果数组的 长度大于等于64，就会将该节点的链表转换成树。 通过扩容数组的方式来把这些节点给分散开，然后将这些元素复制到扩容后的新数组中，同 一个Bucket中的元素通过哈希值的数组长度位来重新确定位置，可能还是放在原来的位置，也可能 放到新的位置。而且，在扩容完成之后，如果之前某个节点是树，但是现在该节点的“Key-Value 对”数又小于等于6个，就会将该树转为链表。 什么时候扩容？当前容量超过阈值，也就是链表中元素个数超过默认设置（8个）时，如果数 组table的大小还未超过64，此时就进行数组的扩容，如果超过就将链表转化成红黑树。</p><h2 id="京东二面——多线程-详尽地对比下synchronized和reentrantlock的异同" tabindex="-1"><a class="header-anchor" href="#京东二面——多线程-详尽地对比下synchronized和reentrantlock的异同" aria-hidden="true">#</a> 京东二面——多线程：详尽地对比下synchronized和ReentrantLock的异同？</h2><h3 id="synchronized实现原理" tabindex="-1"><a class="header-anchor" href="#synchronized实现原理" aria-hidden="true">#</a> synchronized实现原理</h3><p>对象头由两部分组成</p><ul><li>Mark Word：存储自身的运行时数据，例如 HashCode、GC 年龄、锁相关信息等内容。</li><li>Klass Pointer：类型指针指向它的类元数据的指针。</li></ul><p>64 位虚拟机 Mark Word 是 64bit 其结构如下：</p><p><img src="`+l+'" alt="img" loading="lazy"></p><p>在 JDK 6 中虚拟机团队对锁进行了重要改进，优化了其性能引入了 <code>偏向锁</code>、<code>轻量级锁</code>、<code>适应性自旋</code>、<code>锁消除</code>、<code>锁粗化</code>等实现，其中 <code>锁消除</code>和<code>锁粗化</code>本文不做详细讨论其余内容我们将对其进行逐一探究。</p><p>总体上来说锁状态升级流程如下：</p><p><img src="'+h+'" alt="img" loading="lazy"></p>',35),f={href:"https://xiaomi-info.github.io/2020/03/24/synchronized/",target:"_blank",rel:"noopener noreferrer"},S=e('<p>synchronized和ReentrantLock都是Java中用于实现线程同步的机制，它们的主要目的是确保多个线程之间对共享资源的访问是安全的。下面是它们的异同点：</p><p><strong>相同点：</strong></p><ol><li><strong>线程同步：</strong> synchronized和ReentrantLock都可以用于线程同步，确保多个线程之间对共享资源的访问是安全的，避免竞态条件（race condition）和数据不一致问题。</li><li><strong>可重入性：</strong> synchronized和ReentrantLock都支持可重入性，即线程可以多次获得同一把锁，而不会死锁。</li><li><strong>阻塞等待：</strong> 当一个线程尝试获取锁而发现锁已经被其他线程持有时，它们都会被阻塞，直到锁可用。</li></ol><p><strong>不同点：</strong></p><ol><li><strong>使用方式：</strong><ul><li>synchronized是Java语言级别的关键字，用于实现隐式锁。在使用时，直接在方法或代码块前加上synchronized关键字即可。</li><li>ReentrantLock是Java中的一个类，它提供了显式的锁机制。需要通过创建一个ReentrantLock对象，并在需要的时候手动调用lock()和unlock()方法来控制锁的获取和释放。</li></ul></li><li><strong>灵活性：</strong><ul><li>ReentrantLock相比synchronized更加灵活，它提供了一些高级功能，如可定时的锁等待、可轮询的锁等待、公平锁和非公平锁等，这些功能在一些特定场景下可能会更有用。</li></ul></li><li><strong>性能：</strong><ul><li>在Java 5之前，synchronized的性能通常比ReentrantLock好，因为JVM可以对synchronized进行优化。但是在Java 5以后，ReentrantLock的性能得到了很大的提升，它的性能与synchronized已经相当甚至更好，在某些情况下甚至可以更加灵活和高效。</li></ul></li><li><strong>异常处理：</strong><ul><li>使用synchronized时，如果在锁定的代码块中发生异常，JVM会自动释放锁。而使用ReentrantLock时，你需要手动在finally块中释放锁，否则可能会导致死锁或其他问题。</li></ul></li></ol><h2 id="京东二面——多线程-那么请谈谈aqs框架是怎么回事儿" tabindex="-1"><a class="header-anchor" href="#京东二面——多线程-那么请谈谈aqs框架是怎么回事儿" aria-hidden="true">#</a> 京东二面——多线程：那么请谈谈AQS框架是怎么回事儿？</h2><h1 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h1><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。它是一个Java提高的底层同步工具类，比如CountDownLatch、ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS实现。AQS是一个抽象类，提供了并发的基础执行框架，过程如下图所示：</p><p><img src="'+p+`" alt="" loading="lazy"></p><ol><li>获取state同步状态，</li><li>成功加锁执行业务逻辑后释放锁，然后唤醒等待队列的节点。失败构建Node和封装线程，并将Node信息队列尾部，阻塞当前线程。</li></ol><p>AQS有三种同步方式，独占式（ReentrantLock）、共享式(Semaphore)、组合(ReentrantReadWriteLock)，AQS提供了底层支持，支持自由组装实现。</p><p><strong>AQS核心组成：</strong></p><p>AQS出于“分离变与不变”的原则，基于模板模式实现。AQS为锁获取、锁释放的排队和出 队过程提供了一系列的模板方法。由于JUC的显式锁种类丰富，因此AQS将不同锁的具体操作抽取 为钩子方法，供各种锁的子类（或者其内部类）去实现。</p><ol><li><strong>转态标志位</strong></li></ol><p>AQS中维持了一个单一的volatile修饰的状态信息state，AQS使用int类型的state标示锁的状态， 可以理解为锁的同步状态。由于setState()无法保证原子性，因此AQS给我们提供了compareAndSetState()方法利用底层 UnSafe的CAS机制 来实现原子性 。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token comment">//同步状态，使用volatile保证线程可见 </span>
 <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>队列节点类</strong></li></ol><p>AQS是一个虚拟队列，不存在队列实例，仅存在节点之间的前后关系。节点类型通过内部类 Node定义。</p><ol start="3"><li><strong>FIFO双向同步队列</strong></li></ol><p>AQS的内部队列是CLH队列的变种，每当线程通过AQS获取锁失败时，线程将被封装成一个Node 节点，通过CAS原子操作插入队列尾部。当有线程释放锁时，AQS会尝试让队首的后驱节点占用锁。 AQS是一个通过内置的FIFO双向队列来完成线程的排队工作，内部通过节点head和tail记录队 首和队尾元素，元素的节点类型为Node类型。</p><p><strong>JUC 显式锁与 AQS 的关系</strong></p><p>AQS是java.util.concurrent包的一个同步器，它实现了锁的基本抽象功能，支持独占锁与共享锁 两种方式。该类使用模板模式来实现的，成为构建锁和同步器的框架，使用该类可以简单且高效地 构造出应用广泛的同步器（或者等待队列）。 <strong>java.util.concurrent.locks</strong>包中的显式锁如ReentrantLock、ReentrantReadWriteLock，线程同步工具 如Semaphore，异步回调工具如FutureTask等，内部都使用了AQS作为等待队列。通过开发工具进行 AQS的子类导航会发现大量的AQS子类以内部类的形式使用</p><h2 id="京东二面——多线程-java中乐观锁的实现原理是什么" tabindex="-1"><a class="header-anchor" href="#京东二面——多线程-java中乐观锁的实现原理是什么" aria-hidden="true">#</a> 京东二面——多线程：Java中乐观锁的实现原理是什么？</h2><p>主要有两种实现方式：CAS（Compare and Swap）和版本号控制。CAS是实现乐观锁的核心算法，它通过比较内存中的值是否和预期的值相等来判断是否存在冲突。如果存在，则返回失败；如果不存在，则执行更新操作。</p><h2 id="美团二面——多线程-什么是可重入性-为什么说synchronized是可重入锁" tabindex="-1"><a class="header-anchor" href="#美团二面——多线程-什么是可重入性-为什么说synchronized是可重入锁" aria-hidden="true">#</a> 美团二面——多线程：什么是可重入性，为什么说Synchronized是可重入锁？</h2><p>可重入性是指在一个线程持有锁的情况下，可以再次获取同一个锁，而不会因为自己已经持有该锁而发生死锁。一个锁如果支持可重入性，那么同一个线程在持有锁的情况下，可以多次进入由该锁保护的代码块，而不会被阻塞。</p><p>在Java中，synchronized关键字是可重入锁的典型代表。当一个线程获得了一个对象的锁之后，如果该线程再次尝试获取这个锁，它仍然可以成功，因为Java的synchronized机制会记录锁的持有者和锁的计数器。在每次进入synchronized块时，计数器会递增；当线程退出synchronized块时，计数器会递减。只有当计数器归零时，锁才会完全释放。</p><p>这种机制使得同一个线程可以反复进入同步块，而不会被自己持有的锁所阻塞，确保了程序的正确性和线程安全性。因此，synchronized被称为可重入锁。</p><h2 id="阿里二面——mysql-如何优化大量数据插入的性能" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-如何优化大量数据插入的性能" aria-hidden="true">#</a> 阿里二面——MySQL：如何优化大量数据插入的性能？</h2><ul><li>一条SQL语句插入多条数据。SQL执行效率高的主要原因是合并后日志量（MySQL的binlog和innodb的事务让日志）减少了，降低日志刷盘的数据量和频率，从而提高效率。通过合并SQL语句，同时也能减少SQL语句解析的次数，减少网络传输的IO</li><li>数据有序插入。于数据库插入时，需要维护索引数据，无序的记录会增大维护索引的成本。我们可以参照InnoDB使用的B+tree索引，如果每次插入记录都在索引的最后面，索引的定位效率很高，并且对索引调整较小；如果插入的记录在索引中间，需要B+tree进行分裂合并等处理，会消耗比较多计算资源，并且插入记录的索引定位效率会下降，数据量较大时会有频繁的磁盘操作。</li><li>使用事务可以提高数据的插入效率，这是因为进行一个INSERT操作时，MySQL内部会建立一个事务，在事务内才进行真正插入处理操作。通过使用事务可以减少创建事务的消耗，所有插入都在执行后才进行提交操作。</li></ul><h2 id="腾讯二面——mysql-mysql如何避免死锁" tabindex="-1"><a class="header-anchor" href="#腾讯二面——mysql-mysql如何避免死锁" aria-hidden="true">#</a> 腾讯二面——MySQL：MySQL如何避免死锁？</h2><ul><li>在程序中，操作多张表时，尽量以相同的顺序来访问（避免形成等待环路）；</li><li>批量操作单张表数据的时候，先对数据进行排序（避免形成等待环路）；</li><li>申请足够级别的锁，如果要操作数据，就申请排它锁；</li><li>尽量使用索引访问数据，避免没有 where 条件的操作，避免锁表；</li><li>如果可以，大事务化成小事务；</li><li>使用等值查询而不是范围查询查询数据，命中记录，避免间隙锁对并发的影响。</li></ul><h2 id="腾讯二面——mysql-如何优化mysql的表结构" tabindex="-1"><a class="header-anchor" href="#腾讯二面——mysql-如何优化mysql的表结构" aria-hidden="true">#</a> 腾讯二面——MySQL：如何优化MySQL的表结构？</h2><ul><li>尽量将表字段定义为NOT NULL约束，这时由于在MySQL中含有空值的列很难进行查询优化，NULL值会使索引以及索引的统计信息变得很复杂。</li><li>对于只包含特定类型的字段，可以使用enum、set 等数据类型。</li><li>数值型字段的比较比字符串的比较效率高得多，字段类型尽量使用最小、最简单的数据类型。例如IP地址可以使用int类型。</li><li>尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED。但对整数类型指定宽度，比如INT(11)，没有任何用，因为指定的类型标识范围已经确定。</li><li>VARCHAR的长度只分配真正需要的空间。</li><li>尽量使用TIMESTAMP而非DATETIME，但TIMESTAMP只能表示1970 - 2038年，比DATETIME表示的范围小得多，而且TIMESTAMP的值因时区不同而不同。</li><li>单表不要有太多字段，建议在20以内。</li><li>合理的加入冗余字段可以提高查询速度。</li><li>使用区分度高的字段 作为索引</li></ul><h2 id="美团二面——mysql-什么是执行计划-如何理解" tabindex="-1"><a class="header-anchor" href="#美团二面——mysql-什么是执行计划-如何理解" aria-hidden="true">#</a> 美团二面——MySQL：什么是执行计划？如何理解？</h2><p>MySQL中的执行计划（Execution Plan）是一种详细描述MySQL服务器如何执行特定SQL查询的方式。当你在查询语句前加上关键字<code>EXPLAIN</code>时，MySQL不会真正执行该查询，而是返回一个执行计划，这个计划展示了MySQL查询优化器决定的执行步骤、访问表的顺序、使用的索引以及预期的行读取数量等信息。</p><p>执行计划的主要目的是帮助开发者和DBA理解查询的工作原理，包括但不限于以下几个关键点：</p><ol><li><strong>id</strong>: 表示执行计划中查询的各个部分的执行顺序，同一组内的ID相同则一起执行。</li><li><strong>select_type</strong>: 描述查询的类型，如SIMPLE（简单查询）、PRIMARY（主查询）、SUBQUERY（子查询）等。</li><li><strong>table</strong>: 显示查询涉及到的表。</li><li><strong>partitions</strong>: 如果表有分区，则显示计划访问的分区信息。</li><li><strong>type</strong>: 表示表连接或访问类型，例如ALL（全表扫描）、INDEX（全索引扫描）、RANGE（索引范围扫描）、REF（使用非唯一索引或唯一索引的一部分做等值或范围查询）、EQ_REF（唯一索引等值查询）、CONST（常量表，即通过主键或唯一索引直接定位一行）等。</li><li><strong>possible_keys</strong>: 列出MySQL认为可能使用到的索引。</li><li><strong>key</strong>: 实际上选择使用的索引。</li><li><strong>key_len</strong>: 表示所选索引的长度。</li><li><strong>ref</strong>: 显示哪个列或常量与key一起被用于查找索引列的值。</li><li><strong>rows</strong>: 预估MySQL为了获取查询结果需要读取的行数。</li><li><strong>filtered</strong>: 表示按照表条件过滤后，能够返回结果的比例（%）。</li><li><strong>Extra</strong>: 提供其他重要信息，如是否使用了临时表、文件排序、全索引扫描、LIMIT优化等。</li></ol><p>通过解读执行计划，你可以发现查询性能瓶颈，识别未正确使用或缺失的索引，判断是否进行了全表扫描或其他低效操作，并据此进行针对性的SQL优化和表结构改进。</p><h2 id="字节二面——mysql-什么是慢查询-如何避免" tabindex="-1"><a class="header-anchor" href="#字节二面——mysql-什么是慢查询-如何避免" aria-hidden="true">#</a> 字节二面——MySQL：什么是慢查询，如何避免？</h2><p>MySQL中的慢查询是指那些执行时间较长、超出一定阈值的SQL查询语句。在MySQL中，默认情况下，当一条SQL语句的执行时间超过了<code>long_query_time</code>变量指定的秒数时，这条查询就会被认为是“慢查询”。MySQL提供了慢查询日志功能，允许管理员记录这些慢查询以供后续分析和优化。</p><p>避免MySQL慢查询的方法主要包括：</p><ol><li><p><strong>合理创建和使用索引</strong>：</p><ul><li>分析查询语句，确保在WHERE、JOIN和ORDER BY等子句中经常用到的列上创建了适当的索引。</li><li>使用覆盖索引（Covering Index），索引包含了查询所需的全部数据，从而避免回表查询。</li></ul></li><li><p><strong>优化查询语句</strong>：</p><ul><li>避免全表扫描，特别是对大数据量的表，应当利用索引来加速查询。</li><li>减少JOIN操作的数量，简化查询复杂度，或者优化JOIN条件和JOIN顺序。</li><li>避免在WHERE子句中使用函数或计算表达式，这通常会使索引失效。</li></ul></li><li><p><strong>调整数据库参数</strong>：</p><ul><li>调整<code>long_query_time</code>参数，使之更符合实际需求，尽早捕捉潜在的慢查询。</li><li>设置合理的缓存策略，如查询缓存（Query Cache，但在MySQL 8.0之后已被弃用）或结果集缓存。</li></ul></li><li><p><strong>合理设计表结构</strong>：</p><ul><li>数据库设计时遵循规范，减少冗余和数据碎片。</li><li>分区表或分表策略，将大表分成小表以分散负载。</li></ul></li><li><p><strong>硬件和架构优化</strong>：</p><ul><li>根据负载情况提升硬件配置，比如增大内存、使用更快的磁盘设备或启用SSD。</li><li>分布式数据库设计，通过水平扩展缓解单台服务器的压力。</li></ul></li><li><p><strong>监控和分析</strong>：</p><ul><li>使用诸如<code>EXPLAIN</code>命令分析查询执行计划，了解MySQL是如何执行查询的。</li><li>启用慢查询日志并使用专门的工具（如Percona Toolkit中的<code>pt-query-digest</code>）进行分析，找出问题所在并针对性优化。</li></ul></li><li><p><strong>代码层面优化</strong>：</p><ul><li>避免在应用程序中编写复杂的嵌套循环查询，尤其是在高并发环境下。</li><li>对于批量操作，尽量采用批量插入或批处理更新、删除操作，减少网络交互次数。</li></ul></li></ol><p>总之，避免MySQL慢查询需要综合运用数据库设计、SQL优化、索引策略、服务器配置调整等多种手段，并结合实际业务场景不断监测和调优。</p><h2 id="阿里二面——mysql-mysql的优化可以从哪些方面考虑" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-mysql的优化可以从哪些方面考虑" aria-hidden="true">#</a> 阿里二面——MySQL：MySQL的优化可以从哪些方面考虑？</h2><h2 id="阿里二面——mysql-为什么mysql选择b-树作为索引" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-为什么mysql选择b-树作为索引" aria-hidden="true">#</a> 阿里二面——MySQL：为什么MySQL选择B+树作为索引？</h2><h2 id="腾讯二面——mybatis-谈谈你对mybatis的整体理解" tabindex="-1"><a class="header-anchor" href="#腾讯二面——mybatis-谈谈你对mybatis的整体理解" aria-hidden="true">#</a> 腾讯二面——MyBatis：谈谈你对MyBatis的整体理解</h2><h2 id="字节二面——mybatis-谈谈mybatis和spring整合的原理" tabindex="-1"><a class="header-anchor" href="#字节二面——mybatis-谈谈mybatis和spring整合的原理" aria-hidden="true">#</a> 字节二面——MyBatis：谈谈MyBatis和Spring整合的原理</h2><h2 id="字节二面——mybatis-谈谈你对mybatis中的类型转换模块的理解" tabindex="-1"><a class="header-anchor" href="#字节二面——mybatis-谈谈你对mybatis中的类型转换模块的理解" aria-hidden="true">#</a> 字节二面——MyBatis：谈谈你对MyBatis中的类型转换模块的理解</h2><h2 id="字节二面——mybatis-谈谈你对mybatis中的反射模块的理解" tabindex="-1"><a class="header-anchor" href="#字节二面——mybatis-谈谈你对mybatis中的反射模块的理解" aria-hidden="true">#</a> 字节二面——MyBatis：谈谈你对MyBatis中的反射模块的理解</h2><h2 id="字节二面——mybatis-谈谈你对mapper接口的设计理解" tabindex="-1"><a class="header-anchor" href="#字节二面——mybatis-谈谈你对mapper接口的设计理解" aria-hidden="true">#</a> 字节二面——MyBatis：谈谈你对Mapper接口的设计理解</h2><h2 id="字节二面——mybatis-谈谈你对mybatis中的事务模块的设计理解" tabindex="-1"><a class="header-anchor" href="#字节二面——mybatis-谈谈你对mybatis中的事务模块的设计理解" aria-hidden="true">#</a> 字节二面——MyBatis：谈谈你对MyBatis中的事务模块的设计理解</h2><h2 id="字节二面——mybatis-谈谈你对mybatis中的数据源模块的设计理解" tabindex="-1"><a class="header-anchor" href="#字节二面——mybatis-谈谈你对mybatis中的数据源模块的设计理解" aria-hidden="true">#</a> 字节二面——MyBatis：谈谈你对MyBatis中的数据源模块的设计理解</h2><h2 id="字节二面——mybatis-谈谈你对mybatis中记录sql日志的原理理解" tabindex="-1"><a class="header-anchor" href="#字节二面——mybatis-谈谈你对mybatis中记录sql日志的原理理解" aria-hidden="true">#</a> 字节二面——MyBatis：谈谈你对MyBatis中记录SQL日志的原理理解</h2><h2 id="字节二面——mybatis-谈谈你对mybatis中日志模块的理解" tabindex="-1"><a class="header-anchor" href="#字节二面——mybatis-谈谈你对mybatis中日志模块的理解" aria-hidden="true">#</a> 字节二面——MyBatis：谈谈你对MyBatis中日志模块的理解</h2><h2 id="阿里二面——mybatis-mybatis中如何实现多个参数传递" tabindex="-1"><a class="header-anchor" href="#阿里二面——mybatis-mybatis中如何实现多个参数传递" aria-hidden="true">#</a> 阿里二面——MyBatis：MyBatis中如何实现多个参数传递</h2><h2 id="阿里二面——mybatis-如何调整mybatis中的执行器的类型" tabindex="-1"><a class="header-anchor" href="#阿里二面——mybatis-如何调整mybatis中的执行器的类型" aria-hidden="true">#</a> 阿里二面——MyBatis：如何调整MyBatis中的执行器的类型</h2><h2 id="阿里二面——mybatis-谈谈你对mybatis中的executor的理解" tabindex="-1"><a class="header-anchor" href="#阿里二面——mybatis-谈谈你对mybatis中的executor的理解" aria-hidden="true">#</a> 阿里二面——MyBatis：谈谈你对MyBatis中的Executor的理解</h2><h2 id="阿里二面——mybatis-当属性名和字段名称不一致的情况怎么办" tabindex="-1"><a class="header-anchor" href="#阿里二面——mybatis-当属性名和字段名称不一致的情况怎么办" aria-hidden="true">#</a> 阿里二面——MyBatis：当属性名和字段名称不一致的情况怎么办？</h2><h2 id="阿里二面——mybatis-谈谈mybatis的编程步骤是怎么样的" tabindex="-1"><a class="header-anchor" href="#阿里二面——mybatis-谈谈mybatis的编程步骤是怎么样的" aria-hidden="true">#</a> 阿里二面——MyBatis：谈谈MyBatis的编程步骤是怎么样的</h2><h2 id="字节二面——mybatis-谈谈你对传统jdbc开发和mybatis编程的区别" tabindex="-1"><a class="header-anchor" href="#字节二面——mybatis-谈谈你对传统jdbc开发和mybatis编程的区别" aria-hidden="true">#</a> 字节二面——MyBatis：谈谈你对传统JDBC开发和MyBatis编程的区别</h2><h2 id="字节二面——mybatis-谈谈你对mybatis的架构设计的理解" tabindex="-1"><a class="header-anchor" href="#字节二面——mybatis-谈谈你对mybatis的架构设计的理解" aria-hidden="true">#</a> 字节二面——MyBatis：谈谈你对MyBatis的架构设计的理解</h2><h2 id="字节二面——mybatis-不同的mapper映射文件中id是否可以相同" tabindex="-1"><a class="header-anchor" href="#字节二面——mybatis-不同的mapper映射文件中id是否可以相同" aria-hidden="true">#</a> 字节二面——MyBatis：不同的Mapper映射文件中id是否可以相同</h2><h2 id="字节二面——mybatis-谈谈mybatis中如何获取自增的主键" tabindex="-1"><a class="header-anchor" href="#字节二面——mybatis-谈谈mybatis中如何获取自增的主键" aria-hidden="true">#</a> 字节二面——MyBatis：谈谈MyBatis中如何获取自增的主键</h2><h2 id="阿里二面——mybatis-谈谈mybatis中的mapper接口的使用规则" tabindex="-1"><a class="header-anchor" href="#阿里二面——mybatis-谈谈mybatis中的mapper接口的使用规则" aria-hidden="true">#</a> 阿里二面——MyBatis：谈谈MyBatis中的Mapper接口的使用规则</h2><h2 id="阿里二面——mybatis-谈谈你对mybatis中的拦截器的理解" tabindex="-1"><a class="header-anchor" href="#阿里二面——mybatis-谈谈你对mybatis中的拦截器的理解" aria-hidden="true">#</a> 阿里二面——MyBatis：谈谈你对MyBatis中的拦截器的理解</h2><h2 id="阿里二面——mybatis-谈谈你对mybatis中的延迟加载的理解" tabindex="-1"><a class="header-anchor" href="#阿里二面——mybatis-谈谈你对mybatis中的延迟加载的理解" aria-hidden="true">#</a> 阿里二面——MyBatis：谈谈你对MyBatis中的延迟加载的理解</h2><h2 id="腾讯二面——mybatis-在spring中是如何解决defaultsqlsession的数据安全问题的" tabindex="-1"><a class="header-anchor" href="#腾讯二面——mybatis-在spring中是如何解决defaultsqlsession的数据安全问题的" aria-hidden="true">#</a> 腾讯二面——MyBatis：在Spring中是如何解决DefaultSqlSession的数据安全问题的</h2><h2 id="阿里二面——mybatis-谈谈你对mybatis中的分页的理解" tabindex="-1"><a class="header-anchor" href="#阿里二面——mybatis-谈谈你对mybatis中的分页的理解" aria-hidden="true">#</a> 阿里二面——MyBatis：谈谈你对MyBatis中的分页的理解</h2><h2 id="阿里二面——mybatis-谈谈你对mybatis的理解" tabindex="-1"><a class="header-anchor" href="#阿里二面——mybatis-谈谈你对mybatis的理解" aria-hidden="true">#</a> 阿里二面——MyBatis：谈谈你对MyBatis的理解</h2><h2 id="美团二面——mybatis-谈谈你对sqlsession的理解" tabindex="-1"><a class="header-anchor" href="#美团二面——mybatis-谈谈你对sqlsession的理解" aria-hidden="true">#</a> 美团二面——MyBatis：谈谈你对SqlSession的理解</h2><h2 id="阿里二面——mybatis-谈谈你对sqlsessionfactory的理解" tabindex="-1"><a class="header-anchor" href="#阿里二面——mybatis-谈谈你对sqlsessionfactory的理解" aria-hidden="true">#</a> 阿里二面——MyBatis：谈谈你对SqlSessionFactory的理解</h2><h2 id="阿里二面——mybatis-mybatis中对设计模式的理解" tabindex="-1"><a class="header-anchor" href="#阿里二面——mybatis-mybatis中对设计模式的理解" aria-hidden="true">#</a> 阿里二面——MyBatis：MyBatis中对设计模式的理解</h2><h2 id="阿里二面——mybatis-mybatis中如何实现缓存的扩展" tabindex="-1"><a class="header-anchor" href="#阿里二面——mybatis-mybatis中如何实现缓存的扩展" aria-hidden="true">#</a> 阿里二面——MyBatis：MyBatis中如何实现缓存的扩展</h2><h2 id="腾讯二面——mybatis-mybatis中缓存的理解" tabindex="-1"><a class="header-anchor" href="#腾讯二面——mybatis-mybatis中缓存的理解" aria-hidden="true">#</a> 腾讯二面——MyBatis：MyBatis中缓存的理解</h2><h2 id="阿里二面——mybatis-介绍下mybatis的工作原理" tabindex="-1"><a class="header-anchor" href="#阿里二面——mybatis-介绍下mybatis的工作原理" aria-hidden="true">#</a> 阿里二面——MyBatis：介绍下MyBatis的工作原理</h2><h2 id="阿里二面——rocketmq-讲一讲rocketmq中事务回查机制的实现" tabindex="-1"><a class="header-anchor" href="#阿里二面——rocketmq-讲一讲rocketmq中事务回查机制的实现" aria-hidden="true">#</a> 阿里二面——RocketMQ：讲一讲RocketMQ中事务回查机制的实现</h2><h2 id="字节二面——rocketmq-讲一讲rocketmq中的分布式事务及实现" tabindex="-1"><a class="header-anchor" href="#字节二面——rocketmq-讲一讲rocketmq中的分布式事务及实现" aria-hidden="true">#</a> 字节二面——RocketMQ：讲一讲RocketMQ中的分布式事务及实现</h2><h2 id="蚂蚁二面——rocketmq-rocketmq的总体架构-以及每个组件的功能" tabindex="-1"><a class="header-anchor" href="#蚂蚁二面——rocketmq-rocketmq的总体架构-以及每个组件的功能" aria-hidden="true">#</a> 蚂蚁二面——RocketMQ：RocketMQ的总体架构，以及每个组件的功能？</h2><h2 id="字节二面——rocketmq-使用rocketmq过程中遇到过什么问题" tabindex="-1"><a class="header-anchor" href="#字节二面——rocketmq-使用rocketmq过程中遇到过什么问题" aria-hidden="true">#</a> 字节二面——RocketMQ：使用RocketMQ过程中遇到过什么问题？</h2><h2 id="阿里二面——rocketmq-什么是路由剔除-rocketmq如何进行路由剔除" tabindex="-1"><a class="header-anchor" href="#阿里二面——rocketmq-什么是路由剔除-rocketmq如何进行路由剔除" aria-hidden="true">#</a> 阿里二面——RocketMQ：什么是路由剔除？RocketMQ如何进行路由剔除？</h2><h2 id="字节二面——rocketmq-什么是路由发现-rocketmq如何进行路由发现" tabindex="-1"><a class="header-anchor" href="#字节二面——rocketmq-什么是路由发现-rocketmq如何进行路由发现" aria-hidden="true">#</a> 字节二面——RocketMQ：什么是路由发现？RocketMQ如何进行路由发现？</h2><h2 id="阿里二面——rocketmq-什么是路由注册-rocketmq如何进行路由注册" tabindex="-1"><a class="header-anchor" href="#阿里二面——rocketmq-什么是路由注册-rocketmq如何进行路由注册" aria-hidden="true">#</a> 阿里二面——RocketMQ：什么是路由注册？RocketMQ如何进行路由注册？</h2><h2 id="字节二面——rocketmq-rocketmq中broker的刷盘策略有哪些" tabindex="-1"><a class="header-anchor" href="#字节二面——rocketmq-rocketmq中broker的刷盘策略有哪些" aria-hidden="true">#</a> 字节二面——RocketMQ：Rocketmq中Broker的刷盘策略有哪些？</h2><h2 id="字节二面——rocketmq-rocketmq中broker的部署方式" tabindex="-1"><a class="header-anchor" href="#字节二面——rocketmq-rocketmq中broker的部署方式" aria-hidden="true">#</a> 字节二面——RocketMQ：Rocketmq中Broker的部署方式</h2><h2 id="字节二面——rocketmq-有几百万消息持续积压几小时-说说怎么解决" tabindex="-1"><a class="header-anchor" href="#字节二面——rocketmq-有几百万消息持续积压几小时-说说怎么解决" aria-hidden="true">#</a> 字节二面——RocketMQ：有几百万消息持续积压几小时，说说怎么解决？</h2><h2 id="腾讯二面——rocketmq-让你来设计一个消息队列-你会怎么设计" tabindex="-1"><a class="header-anchor" href="#腾讯二面——rocketmq-让你来设计一个消息队列-你会怎么设计" aria-hidden="true">#</a> 腾讯二面——RocketMQ：让你来设计一个消息队列，你会怎么设计？</h2><h2 id="蚂蚁二面——rocketmq-rocketmq性能比较高的原因" tabindex="-1"><a class="header-anchor" href="#蚂蚁二面——rocketmq-rocketmq性能比较高的原因" aria-hidden="true">#</a> 蚂蚁二面——RocketMQ：RocketMq性能比较高的原因？</h2><h2 id="阿里二面——rocketmq-rocketmq的存储机制了解吗" tabindex="-1"><a class="header-anchor" href="#阿里二面——rocketmq-rocketmq的存储机制了解吗" aria-hidden="true">#</a> 阿里二面——RocketMQ：RocketMq的存储机制了解吗？</h2><h2 id="字节二面——rocketmq-rocketmq如何保证高可用性" tabindex="-1"><a class="header-anchor" href="#字节二面——rocketmq-rocketmq如何保证高可用性" aria-hidden="true">#</a> 字节二面——RocketMQ：Rocketmq如何保证高可用性？</h2><h2 id="美团二面——rocketmq-如何解决重复消费" tabindex="-1"><a class="header-anchor" href="#美团二面——rocketmq-如何解决重复消费" aria-hidden="true">#</a> 美团二面——RocketMQ：如何解决重复消费？</h2><h2 id="字节二面——rocketmq-kafka为什么那么快" tabindex="-1"><a class="header-anchor" href="#字节二面——rocketmq-kafka为什么那么快" aria-hidden="true">#</a> 字节二面——RocketMQ：Kafka为什么那么快？</h2><h2 id="阿里二面——rocketmq-kafka中是怎么做到消息顺序性的" tabindex="-1"><a class="header-anchor" href="#阿里二面——rocketmq-kafka中是怎么做到消息顺序性的" aria-hidden="true">#</a> 阿里二面——RocketMQ：Kafka中是怎么做到消息顺序性的？</h2><h2 id="美团二面——rocketmq-为什么kafka不支持读写分离" tabindex="-1"><a class="header-anchor" href="#美团二面——rocketmq-为什么kafka不支持读写分离" aria-hidden="true">#</a> 美团二面——RocketMQ：为什么Kafka不支持读写分离？</h2><h2 id="美团二面——rocketmq-rabbitmq中交换器4种类型" tabindex="-1"><a class="header-anchor" href="#美团二面——rocketmq-rabbitmq中交换器4种类型" aria-hidden="true">#</a> 美团二面——RocketMQ：RabbitMQ中交换器4种类型？</h2><h2 id="美团二面——rocketmq-kafka适合哪些场景" tabindex="-1"><a class="header-anchor" href="#美团二面——rocketmq-kafka适合哪些场景" aria-hidden="true">#</a> 美团二面——RocketMQ：kafka适合哪些场景？</h2><h2 id="腾讯二面——rocketmq-rabbitmq开启持久化机制-有什么要注意的点" tabindex="-1"><a class="header-anchor" href="#腾讯二面——rocketmq-rabbitmq开启持久化机制-有什么要注意的点" aria-hidden="true">#</a> 腾讯二面——RocketMQ：RabbitMQ开启持久化机制，有什么要注意的点？</h2><h2 id="阿里二面——rocketmq-说一说rabbitmq中的amqp" tabindex="-1"><a class="header-anchor" href="#阿里二面——rocketmq-说一说rabbitmq中的amqp" aria-hidden="true">#</a> 阿里二面——RocketMQ： 说一说RabbitMQ中的AMQP</h2><h2 id="美团二面——rocketmq-kafka中-可以不用zookeeper么" tabindex="-1"><a class="header-anchor" href="#美团二面——rocketmq-kafka中-可以不用zookeeper么" aria-hidden="true">#</a> 美团二面——RocketMQ：kafka中，可以不用zookeeper么？</h2><h2 id="阿里二面——rocketmq-说一说kafka你熟悉的参数" tabindex="-1"><a class="header-anchor" href="#阿里二面——rocketmq-说一说kafka你熟悉的参数" aria-hidden="true">#</a> 阿里二面——RocketMQ：说一说Kafka你熟悉的参数？</h2><h2 id="腾讯二面——rocketmq-rabbitmq上的一个queue中存放的message是否有数量限制" tabindex="-1"><a class="header-anchor" href="#腾讯二面——rocketmq-rabbitmq上的一个queue中存放的message是否有数量限制" aria-hidden="true">#</a> 腾讯二面——RocketMQ：RabbitMQ上的一个queue中存放的message是否有数量限制？</h2><h2 id="阿里二面——rocketmq-rabbitmq中的vhost起什么作用" tabindex="-1"><a class="header-anchor" href="#阿里二面——rocketmq-rabbitmq中的vhost起什么作用" aria-hidden="true">#</a> 阿里二面——RocketMQ：RabbitMQ中的vhost起什么作用？</h2><h2 id="字节二面——rocketmq-kafka的特性" tabindex="-1"><a class="header-anchor" href="#字节二面——rocketmq-kafka的特性" aria-hidden="true">#</a> 字节二面——RocketMQ：Kafka的特性</h2><h2 id="腾讯二面——rocketmq-常见消息队列的比较" tabindex="-1"><a class="header-anchor" href="#腾讯二面——rocketmq-常见消息队列的比较" aria-hidden="true">#</a> 腾讯二面——RocketMQ：常见消息队列的比较</h2><h2 id="京东二面——rocketmq-消息队列有什么优点和缺点" tabindex="-1"><a class="header-anchor" href="#京东二面——rocketmq-消息队列有什么优点和缺点" aria-hidden="true">#</a> 京东二面——RocketMQ：消息队列有什么优点和缺点</h2><h2 id="京东二面——rocketmq-为什么要使用消息队列" tabindex="-1"><a class="header-anchor" href="#京东二面——rocketmq-为什么要使用消息队列" aria-hidden="true">#</a> 京东二面——RocketMQ：为什么要使用消息队列？</h2><h2 id="阿里二面——分布式-什么是read-write-through机制" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-什么是read-write-through机制" aria-hidden="true">#</a> 阿里二面——分布式：什么是Read Write Through机制</h2><h2 id="阿里二面——分布式-什么是cache-aside机制" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-什么是cache-aside机制" aria-hidden="true">#</a> 阿里二面——分布式：什么是Cache Aside机制</h2><h2 id="阿里二面——分布式-认证和授权有什么区别" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-认证和授权有什么区别" aria-hidden="true">#</a> 阿里二面——分布式：认证和授权有什么区别</h2><h2 id="阿里二面——分布式-ribbon的原理是什么" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-ribbon的原理是什么" aria-hidden="true">#</a> 阿里二面——分布式：Ribbon的原理是什么</h2><h2 id="阿里二面——分布式-什么是最大努力通知方案" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-什么是最大努力通知方案" aria-hidden="true">#</a> 阿里二面——分布式：什么是最大努力通知方案</h2><h2 id="阿里二面——分布式-spring-cloud和dubbo如何选择" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-spring-cloud和dubbo如何选择" aria-hidden="true">#</a> 阿里二面——分布式：Spring Cloud和Dubbo如何选择</h2><h2 id="阿里二面——分布式-微服务设计的原则有哪些" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-微服务设计的原则有哪些" aria-hidden="true">#</a> 阿里二面——分布式：微服务设计的原则有哪些</h2><h2 id="阿里二面——分布式-你是如何进行服务划分的" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-你是如何进行服务划分的" aria-hidden="true">#</a> 阿里二面——分布式：你是如何进行服务划分的</h2><h2 id="阿里二面——分布式-如何提升系统的并发能力" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-如何提升系统的并发能力" aria-hidden="true">#</a> 阿里二面——分布式：如何提升系统的并发能力</h2><h2 id="阿里二面——分布式-熔断和降级的区别" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-熔断和降级的区别" aria-hidden="true">#</a> 阿里二面——分布式：熔断和降级的区别</h2><h2 id="美团二面——分布式-分布式系统中为什么引入熔断" tabindex="-1"><a class="header-anchor" href="#美团二面——分布式-分布式系统中为什么引入熔断" aria-hidden="true">#</a> 美团二面——分布式：分布式系统中为什么引入熔断</h2><h2 id="阿里二面——分布式-谈谈你对restful风格的理解" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-谈谈你对restful风格的理解" aria-hidden="true">#</a> 阿里二面——分布式：谈谈你对RESTFul风格的理解</h2><h2 id="阿里二面——分布式-请说说注册中心有哪些操作" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-请说说注册中心有哪些操作" aria-hidden="true">#</a> 阿里二面——分布式：请说说注册中心有哪些操作</h2><h2 id="阿里二面——分布式-请说说注册中心的数据存储结构" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-请说说注册中心的数据存储结构" aria-hidden="true">#</a> 阿里二面——分布式：请说说注册中心的数据存储结构</h2><h2 id="阿里二面——分布式-rocketmq在分布式事务中的应用" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-rocketmq在分布式事务中的应用" aria-hidden="true">#</a> 阿里二面——分布式：RocketMQ在分布式事务中的应用</h2><h2 id="阿里二面——分布式-什么是可靠消息最终一致性方案" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-什么是可靠消息最终一致性方案" aria-hidden="true">#</a> 阿里二面——分布式：什么是可靠消息最终一致性方案</h2><h2 id="阿里二面——分布式-什么是base理论" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-什么是base理论" aria-hidden="true">#</a> 阿里二面——分布式：什么是BASE理论</h2><h2 id="阿里二面——分布式-什么是cap定理" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-什么是cap定理" aria-hidden="true">#</a> 阿里二面——分布式：什么是CAP定理</h2><h2 id="阿里二面——分布式-数据库如何处理大数据量" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-数据库如何处理大数据量" aria-hidden="true">#</a> 阿里二面——分布式：数据库如何处理大数据量</h2><h2 id="阿里二面——分布式-什么是令牌桶算法" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-什么是令牌桶算法" aria-hidden="true">#</a> 阿里二面——分布式：什么是令牌桶算法</h2><h2 id="阿里二面——分布式-什么是漏桶算法" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-什么是漏桶算法" aria-hidden="true">#</a> 阿里二面——分布式：什么是漏桶算法</h2><h2 id="阿里二面——分布式-什么是滑动时间窗口算法" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-什么是滑动时间窗口算法" aria-hidden="true">#</a> 阿里二面——分布式：什么是滑动时间窗口算法</h2><h2 id="阿里二面——分布式-什么是固定时间窗口限流算法" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-什么是固定时间窗口限流算法" aria-hidden="true">#</a> 阿里二面——分布式：什么是固定时间窗口限流算法</h2><h2 id="阿里二面——分布式-常用的负载均衡算法有哪些" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-常用的负载均衡算法有哪些" aria-hidden="true">#</a> 阿里二面——分布式：常用的负载均衡算法有哪些</h2><h2 id="阿里二面——分布式-分布式id的生成方案有哪些" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-分布式id的生成方案有哪些" aria-hidden="true">#</a> 阿里二面——分布式：分布式id的生成方案有哪些</h2><h2 id="阿里二面——分布式-消息队列和事件表实现分布式事务" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-消息队列和事件表实现分布式事务" aria-hidden="true">#</a> 阿里二面——分布式：消息队列和事件表实现分布式事务</h2><h2 id="阿里二面——分布式-什么是补偿性事务" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-什么是补偿性事务" aria-hidden="true">#</a> 阿里二面——分布式：什么是补偿性事务</h2><h2 id="阿里二面——分布式-什么是两阶段提交协议" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-什么是两阶段提交协议" aria-hidden="true">#</a> 阿里二面——分布式：什么是两阶段提交协议</h2><h2 id="阿里二面——分布式-说说那你对分布式事务的理解" tabindex="-1"><a class="header-anchor" href="#阿里二面——分布式-说说那你对分布式事务的理解" aria-hidden="true">#</a> 阿里二面——分布式：说说那你对分布式事务的理解</h2><h2 id="美团二面——分布式-分布式幂等性如何设计" tabindex="-1"><a class="header-anchor" href="#美团二面——分布式-分布式幂等性如何设计" aria-hidden="true">#</a> 美团二面——分布式：分布式幂等性如何设计</h2><h2 id="百度二面——redis-redis过期策略都有哪些-lru算法知道吗" tabindex="-1"><a class="header-anchor" href="#百度二面——redis-redis过期策略都有哪些-lru算法知道吗" aria-hidden="true">#</a> 百度二面——Redis： Redis过期策略都有哪些？LRU算法知道吗？</h2><h2 id="蚂蚁金服二面——redis-什么时候选择redis-什么时候选择memcached" tabindex="-1"><a class="header-anchor" href="#蚂蚁金服二面——redis-什么时候选择redis-什么时候选择memcached" aria-hidden="true">#</a> 蚂蚁金服二面——Redis：什么时候选择Redis，什么时候选择Memcached？</h2><h2 id="京东二面——redis-什么情况下可能会导致redis阻塞" tabindex="-1"><a class="header-anchor" href="#京东二面——redis-什么情况下可能会导致redis阻塞" aria-hidden="true">#</a> 京东二面——Redis：什么情况下可能会导致Redis阻塞？</h2><h2 id="字节跳动二面——redis-热点数据和冷数据是什么" tabindex="-1"><a class="header-anchor" href="#字节跳动二面——redis-热点数据和冷数据是什么" aria-hidden="true">#</a> 字节跳动二面——Redis：热点数据和冷数据是什么</h2><h2 id="美团二面——redis-redis常见性能问题和解决方案有哪些" tabindex="-1"><a class="header-anchor" href="#美团二面——redis-redis常见性能问题和解决方案有哪些" aria-hidden="true">#</a> 美团二面——Redis：Redis常见性能问题和解决方案有哪些？</h2><h2 id="美团二面——redis-redis集群会有写操作丢失吗-为什么" tabindex="-1"><a class="header-anchor" href="#美团二面——redis-redis集群会有写操作丢失吗-为什么" aria-hidden="true">#</a> 美团二面——Redis：Redis集群会有写操作丢失吗？为什么？</h2><h2 id="美团二面——redis-说一说redis哈希槽的概念" tabindex="-1"><a class="header-anchor" href="#美团二面——redis-说一说redis哈希槽的概念" aria-hidden="true">#</a> 美团二面——Redis：说一说Redis哈希槽的概念？</h2><h2 id="蚂蚁金服二面——redis-redis集群方案什么情况下会导致整个集群不可用" tabindex="-1"><a class="header-anchor" href="#蚂蚁金服二面——redis-redis集群方案什么情况下会导致整个集群不可用" aria-hidden="true">#</a> 蚂蚁金服二面——Redis：Redis集群方案什么情况下会导致整个集群不可用？</h2><h2 id="腾讯二面——redis-redis集群方案应该怎么做" tabindex="-1"><a class="header-anchor" href="#腾讯二面——redis-redis集群方案应该怎么做" aria-hidden="true">#</a> 腾讯二面——Redis：Redis集群方案应该怎么做？</h2><h2 id="腾讯二面——redis-如何保证缓存与数据库双写时的数据一致性" tabindex="-1"><a class="header-anchor" href="#腾讯二面——redis-如何保证缓存与数据库双写时的数据一致性" aria-hidden="true">#</a> 腾讯二面——Redis：如何保证缓存与数据库双写时的数据一致性</h2><h2 id="阿里二面——redis-为什么redis需要把所有数据放到内存中" tabindex="-1"><a class="header-anchor" href="#阿里二面——redis-为什么redis需要把所有数据放到内存中" aria-hidden="true">#</a> 阿里二面——Redis：为什么Redis需要把所有数据放到内存中？</h2><h2 id="阿里二面——redis-redis持久化方式有哪些-有什么区别" tabindex="-1"><a class="header-anchor" href="#阿里二面——redis-redis持久化方式有哪些-有什么区别" aria-hidden="true">#</a> 阿里二面——Redis：Redis持久化方式有哪些？有什么区别？</h2><h2 id="字节跳动二面——redis-怎么提高缓存命中率" tabindex="-1"><a class="header-anchor" href="#字节跳动二面——redis-怎么提高缓存命中率" aria-hidden="true">#</a> 字节跳动二面——Redis：怎么提高缓存命中率？</h2><h2 id="蚂蚁金服二面——redis-redis如何解决key冲突" tabindex="-1"><a class="header-anchor" href="#蚂蚁金服二面——redis-redis如何解决key冲突" aria-hidden="true">#</a> 蚂蚁金服二面——Redis：Redis如何解决key冲突？</h2><h2 id="美团二面——redis-什么是bigkey-会有什么影响" tabindex="-1"><a class="header-anchor" href="#美团二面——redis-什么是bigkey-会有什么影响" aria-hidden="true">#</a> 美团二面——Redis：什么是bigkey？会有什么影响？</h2><h2 id="美团二面——redis-怎么使用redis实现消息队列" tabindex="-1"><a class="header-anchor" href="#美团二面——redis-怎么使用redis实现消息队列" aria-hidden="true">#</a> 美团二面——Redis：怎么使用Redis实现消息队列？</h2><h2 id="字节跳动二面——redis-使用redis如何设计分布式锁" tabindex="-1"><a class="header-anchor" href="#字节跳动二面——redis-使用redis如何设计分布式锁" aria-hidden="true">#</a> 字节跳动二面——Redis：使用Redis如何设计分布式锁？</h2><h2 id="蚂蚁金服二面——redis-什么是缓存雪崩-如何避免" tabindex="-1"><a class="header-anchor" href="#蚂蚁金服二面——redis-什么是缓存雪崩-如何避免" aria-hidden="true">#</a> 蚂蚁金服二面——Redis：什么是缓存雪崩？如何避免？</h2><h2 id="阿里二面——redis-什么是缓存穿透-如何避免" tabindex="-1"><a class="header-anchor" href="#阿里二面——redis-什么是缓存穿透-如何避免" aria-hidden="true">#</a> 阿里二面——Redis：什么是缓存穿透？如何避免？</h2><h2 id="京东二面——redis-redis的过期策略以及内存淘汰机制" tabindex="-1"><a class="header-anchor" href="#京东二面——redis-redis的过期策略以及内存淘汰机制" aria-hidden="true">#</a> 京东二面——Redis：Redis的过期策略以及内存淘汰机制？</h2><h2 id="蚂蚁金服二面——redis-怎么理解redis中事务" tabindex="-1"><a class="header-anchor" href="#蚂蚁金服二面——redis-怎么理解redis中事务" aria-hidden="true">#</a> 蚂蚁金服二面——Redis：怎么理解Redis中事务？</h2><h2 id="蚂蚁金服二面——redis-redis与memcached相对有哪些优势" tabindex="-1"><a class="header-anchor" href="#蚂蚁金服二面——redis-redis与memcached相对有哪些优势" aria-hidden="true">#</a> 蚂蚁金服二面——Redis：Redis与memcached相对有哪些优势？</h2><h2 id="美团二面——redis-redis6-0之前为什么一直不使用多线程" tabindex="-1"><a class="header-anchor" href="#美团二面——redis-redis6-0之前为什么一直不使用多线程" aria-hidden="true">#</a> 美团二面——Redis：Redis6.0之前为什么一直不使用多线程？</h2><h2 id="蚂蚁金服二面——redis-为什么要用redis" tabindex="-1"><a class="header-anchor" href="#蚂蚁金服二面——redis-为什么要用redis" aria-hidden="true">#</a> 蚂蚁金服二面——Redis：为什么要用Redis？</h2><h2 id="阿里二面——redis-redis有哪些高级功能" tabindex="-1"><a class="header-anchor" href="#阿里二面——redis-redis有哪些高级功能" aria-hidden="true">#</a> 阿里二面——Redis：Redis有哪些高级功能？</h2><h2 id="美团二面——redis-redis6-0为什么要引入多线程" tabindex="-1"><a class="header-anchor" href="#美团二面——redis-redis6-0为什么要引入多线程" aria-hidden="true">#</a> 美团二面——Redis：Redis6.0为什么要引入多线程？</h2><h2 id="美团二面——redis-redis合适的应用场景" tabindex="-1"><a class="header-anchor" href="#美团二面——redis-redis合适的应用场景" aria-hidden="true">#</a> 美团二面——Redis：Redis合适的应用场景？</h2><h2 id="京东二面——redis-redis为什么快" tabindex="-1"><a class="header-anchor" href="#京东二面——redis-redis为什么快" aria-hidden="true">#</a> 京东二面——Redis：Redis为什么快？</h2><h2 id="阿里一面——springboot-运行springboot项目的方式" tabindex="-1"><a class="header-anchor" href="#阿里一面——springboot-运行springboot项目的方式" aria-hidden="true">#</a> 阿里一面——SpringBoot：运行SpringBoot项目的方式</h2><h2 id="阿里一面——springboot-我们如何连接一个像-mysql-或者orcale-一样的外部数据库" tabindex="-1"><a class="header-anchor" href="#阿里一面——springboot-我们如何连接一个像-mysql-或者orcale-一样的外部数据库" aria-hidden="true">#</a> 阿里一面——SpringBoot：我们如何连接一个像 MySQL 或者Orcale 一样的外部数据库？</h2><h2 id="阿里一面——springboot-什么是springboot" tabindex="-1"><a class="header-anchor" href="#阿里一面——springboot-什么是springboot" aria-hidden="true">#</a> 阿里一面——SpringBoot：什么是SpringBoot</h2><h2 id="阿里一面——springboot-什么是-spring-boot-starter" tabindex="-1"><a class="header-anchor" href="#阿里一面——springboot-什么是-spring-boot-starter" aria-hidden="true">#</a> 阿里一面——SpringBoot：什么是 Spring Boot Starter ？</h2><h2 id="阿里二面——springboot-如何重新加载spring-boot上的更改-而无需重新启动服务器" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-如何重新加载spring-boot上的更改-而无需重新启动服务器" aria-hidden="true">#</a> 阿里二面——SpringBoot：如何重新加载Spring Boot上的更改，而无需重新启动服务器？</h2><h2 id="阿里二面——springboot-如何在-spring-boot-启动的时候运行一些特定的代码" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-如何在-spring-boot-启动的时候运行一些特定的代码" aria-hidden="true">#</a> 阿里二面——SpringBoot：如何在 Spring Boot 启动的时候运行一些特定的代码？</h2><h2 id="阿里二面——springboot-如何实现springboot-应用程序的安全性" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-如何实现springboot-应用程序的安全性" aria-hidden="true">#</a> 阿里二面——SpringBoot：如何实现SpringBoot 应用程序的安全性</h2><h2 id="阿里二面——springboot-你如何理解-spring-boot-配置加载顺序" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-你如何理解-spring-boot-配置加载顺序" aria-hidden="true">#</a> 阿里二面——SpringBoot：你如何理解 Spring Boot 配置加载顺序？</h2><h2 id="阿里一面——springboot-介绍几个常用的starter" tabindex="-1"><a class="header-anchor" href="#阿里一面——springboot-介绍几个常用的starter" aria-hidden="true">#</a> 阿里一面——SpringBoot：介绍几个常用的starter</h2><h2 id="阿里二面——springboot-springboot自动装配的流程是怎样的" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-springboot自动装配的流程是怎样的" aria-hidden="true">#</a> 阿里二面——SpringBoot：SpringBoot自动装配的流程是怎样的？</h2><h2 id="阿里二面——springboot-springboot自动装配的核心配置文件有哪些" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-springboot自动装配的核心配置文件有哪些" aria-hidden="true">#</a> 阿里二面——SpringBoot：SpringBoot自动装配的核心配置文件有哪些？</h2><h2 id="阿里二面——springboot-springboot中如何实现定时任务" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-springboot中如何实现定时任务" aria-hidden="true">#</a> 阿里二面——SpringBoot：SpringBoot中如何实现定时任务</h2><h2 id="阿里二面——springboot-springboot中如何配置log4j" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-springboot中如何配置log4j" aria-hidden="true">#</a> 阿里二面——SpringBoot：SpringBoot中如何配置log4j</h2><h2 id="阿里二面——springboot-springboot如何解决跨域问题" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-springboot如何解决跨域问题" aria-hidden="true">#</a> 阿里二面——SpringBoot：SpringBoot如何解决跨域问题</h2><h2 id="阿里二面——springboot-springboot的优点" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-springboot的优点" aria-hidden="true">#</a> 阿里二面——SpringBoot：SpringBoot的优点</h2><h2 id="阿里二面——springboot-springboot的run方法做了什么事情" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-springboot的run方法做了什么事情" aria-hidden="true">#</a> 阿里二面——SpringBoot：SpringBoot的run方法做了什么事情</h2><h2 id="阿里二面——springboot-springboot打成的jar和普通jar有什么区别" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-springboot打成的jar和普通jar有什么区别" aria-hidden="true">#</a> 阿里二面——SpringBoot：SpringBoot打成的jar和普通jar有什么区别</h2><h2 id="阿里二面——springboot-springboot-中的监视器是什么呢" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-springboot-中的监视器是什么呢" aria-hidden="true">#</a> 阿里二面——SpringBoot：SpringBoot 中的监视器是什么呢</h2><h2 id="阿里二面——springboot-spring-boot、spring-mvc-和-spring-有什么区别" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-spring-boot、spring-mvc-和-spring-有什么区别" aria-hidden="true">#</a> 阿里二面——SpringBoot：Spring Boot、Spring MVC 和 Spring 有什么区别？</h2><h2 id="阿里二面——springboot-spring-boot-支持哪些日志框架-推荐和默认的日志框架是哪个" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-spring-boot-支持哪些日志框架-推荐和默认的日志框架是哪个" aria-hidden="true">#</a> 阿里二面——SpringBoot：Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</h2><h2 id="阿里二面——springboot-spring-boot-有哪几种读取配置的方式" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-spring-boot-有哪几种读取配置的方式" aria-hidden="true">#</a> 阿里二面——SpringBoot：Spring Boot 有哪几种读取配置的方式</h2><h2 id="阿里二面——springboot-spring-boot-需要独立的容器运行吗" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-spring-boot-需要独立的容器运行吗" aria-hidden="true">#</a> 阿里二面——SpringBoot：Spring Boot 需要独立的容器运行吗？</h2><h2 id="阿里二面——springboot-spring-boot-如何定义多套不同环境配置" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-spring-boot-如何定义多套不同环境配置" aria-hidden="true">#</a> 阿里二面——SpringBoot：Spring Boot 如何定义多套不同环境配置？</h2><h2 id="阿里二面——springboot-spring-boot-可以兼容老-spring-项目吗-如何做" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-spring-boot-可以兼容老-spring-项目吗-如何做" aria-hidden="true">#</a> 阿里二面——SpringBoot：Spring Boot 可以兼容老 Spring 项目吗，如何做？</h2><h2 id="阿里二面——springboot-spring-boot-的核心注解是哪个-它主要由哪几个注解组成的" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-spring-boot-的核心注解是哪个-它主要由哪几个注解组成的" aria-hidden="true">#</a> 阿里二面——SpringBoot：Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h2><h2 id="阿里二面——springboot-requestmapping-和-getmapping-的不同之处在哪里" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-requestmapping-和-getmapping-的不同之处在哪里" aria-hidden="true">#</a> 阿里二面——SpringBoot：RequestMapping 和 GetMapping 的不同之处在哪里？</h2><h2 id="阿里二面——springboot-import注解的三种用法" tabindex="-1"><a class="header-anchor" href="#阿里二面——springboot-import注解的三种用法" aria-hidden="true">#</a> 阿里二面——SpringBoot：Import注解的三种用法</h2><h2 id="阿里一面——springboot-bootstrap-yml的意义" tabindex="-1"><a class="header-anchor" href="#阿里一面——springboot-bootstrap-yml的意义" aria-hidden="true">#</a> 阿里一面——SpringBoot：bootstrap.yml的意义</h2><h2 id="美团一面——springboot-enableautoconfiguration注解是干什么的" tabindex="-1"><a class="header-anchor" href="#美团一面——springboot-enableautoconfiguration注解是干什么的" aria-hidden="true">#</a> 美团一面——SpringBoot：@EnableAutoConfiguration注解是干什么的？</h2><h2 id="美团一面——springboot-componentscan注解是干什么的" tabindex="-1"><a class="header-anchor" href="#美团一面——springboot-componentscan注解是干什么的" aria-hidden="true">#</a> 美团一面——SpringBoot：@ComponentScan注解是干什么的？</h2><h2 id="去哪儿网二面——springcloud-zuul有几种过滤器类型-分别是什么" tabindex="-1"><a class="header-anchor" href="#去哪儿网二面——springcloud-zuul有几种过滤器类型-分别是什么" aria-hidden="true">#</a> 去哪儿网二面——SpringCloud：Zuul有几种过滤器类型，分别是什么</h2><h2 id="携程二面——springcloud-apollo客户端设计" tabindex="-1"><a class="header-anchor" href="#携程二面——springcloud-apollo客户端设计" aria-hidden="true">#</a> 携程二面——SpringCloud：Apollo客户端设计</h2><h2 id="携程二面——springcloud-apollo配置发布后的实时推送设计" tabindex="-1"><a class="header-anchor" href="#携程二面——springcloud-apollo配置发布后的实时推送设计" aria-hidden="true">#</a> 携程二面——SpringCloud：Apollo配置发布后的实时推送设计</h2><h2 id="携程二面——springcloud-apollo的整体架构可靠性分析" tabindex="-1"><a class="header-anchor" href="#携程二面——springcloud-apollo的整体架构可靠性分析" aria-hidden="true">#</a> 携程二面——SpringCloud：Apollo的整体架构可靠性分析</h2><h2 id="携程二面——springcloud-apollo的整体架构" tabindex="-1"><a class="header-anchor" href="#携程二面——springcloud-apollo的整体架构" aria-hidden="true">#</a> 携程二面——SpringCloud：Apollo的整体架构</h2><h2 id="拼多多二面——springcloud-从eureka迁移到nacos的解决方案" tabindex="-1"><a class="header-anchor" href="#拼多多二面——springcloud-从eureka迁移到nacos的解决方案" aria-hidden="true">#</a> 拼多多二面——SpringCloud：从Eureka迁移到Nacos的解决方案</h2><h2 id="拼多多二面——springcloud-简述eureka集群架构" tabindex="-1"><a class="header-anchor" href="#拼多多二面——springcloud-简述eureka集群架构" aria-hidden="true">#</a> 拼多多二面——SpringCloud：简述Eureka集群架构</h2><h2 id="拼多多二面——springcloud-简述eureka自我保护机制" tabindex="-1"><a class="header-anchor" href="#拼多多二面——springcloud-简述eureka自我保护机制" aria-hidden="true">#</a> 拼多多二面——SpringCloud：简述Eureka自我保护机制</h2><h2 id="美团二面——springcloud-简述seata的at模式两阶段过程" tabindex="-1"><a class="header-anchor" href="#美团二面——springcloud-简述seata的at模式两阶段过程" aria-hidden="true">#</a> 美团二面——SpringCloud：简述Seata的AT模式两阶段过程</h2><h2 id="美团二面——springcloud-请说一下cap和base理论" tabindex="-1"><a class="header-anchor" href="#美团二面——springcloud-请说一下cap和base理论" aria-hidden="true">#</a> 美团二面——SpringCloud：请说一下CAP和BASE理论</h2><h2 id="阿里二面——springcloud-分布式事务应用的典型场景" tabindex="-1"><a class="header-anchor" href="#阿里二面——springcloud-分布式事务应用的典型场景" aria-hidden="true">#</a> 阿里二面——SpringCloud：分布式事务应用的典型场景</h2><h2 id="字节二面——springcloud-seata中xid怎样通过feign进行全局传递" tabindex="-1"><a class="header-anchor" href="#字节二面——springcloud-seata中xid怎样通过feign进行全局传递" aria-hidden="true">#</a> 字节二面——SpringCloud：Seata中xid怎样通过Feign进行全局传递</h2><h2 id="阿里二面——springcloud-请简述2pc流程以及优缺点" tabindex="-1"><a class="header-anchor" href="#阿里二面——springcloud-请简述2pc流程以及优缺点" aria-hidden="true">#</a> 阿里二面——SpringCloud：请简述2PC流程以及优缺点</h2><h2 id="阿里二面——springcloud-seata支持那些事务模式" tabindex="-1"><a class="header-anchor" href="#阿里二面——springcloud-seata支持那些事务模式" aria-hidden="true">#</a> 阿里二面——SpringCloud：Seata支持那些事务模式？</h2><h2 id="美团二面——springcloud-在gateway中怎样实现服务平滑迁移" tabindex="-1"><a class="header-anchor" href="#美团二面——springcloud-在gateway中怎样实现服务平滑迁移" aria-hidden="true">#</a> 美团二面——SpringCloud：在Gateway中怎样实现服务平滑迁移？</h2><h2 id="美团二面——springcloud-谈谈sentienl服务熔断过程" tabindex="-1"><a class="header-anchor" href="#美团二面——springcloud-谈谈sentienl服务熔断过程" aria-hidden="true">#</a> 美团二面——SpringCloud：谈谈Sentienl服务熔断过程</h2><h2 id="阿里二面——springcloud-谈谈sentienl中使用的限流算法" tabindex="-1"><a class="header-anchor" href="#阿里二面——springcloud-谈谈sentienl中使用的限流算法" aria-hidden="true">#</a> 阿里二面——SpringCloud：谈谈Sentienl中使用的限流算法</h2><h2 id="拼多多二面——springcloud-feign怎样实现认证的传递" tabindex="-1"><a class="header-anchor" href="#拼多多二面——springcloud-feign怎样实现认证的传递" aria-hidden="true">#</a> 拼多多二面——SpringCloud：Feign怎样实现认证的传递？</h2><h2 id="拼多多二面——springcloud-feign的性能优化" tabindex="-1"><a class="header-anchor" href="#拼多多二面——springcloud-feign的性能优化" aria-hidden="true">#</a> 拼多多二面——SpringCloud：Feign的性能优化？</h2><h2 id="拼多多二面——springcloud-ribbon的属性配置和类配置优先级" tabindex="-1"><a class="header-anchor" href="#拼多多二面——springcloud-ribbon的属性配置和类配置优先级" aria-hidden="true">#</a> 拼多多二面——SpringCloud：Ribbon的属性配置和类配置优先级</h2><h2 id="拼多多二面——springcloud-ribbon底层怎样实现不同服务的不同配置" tabindex="-1"><a class="header-anchor" href="#拼多多二面——springcloud-ribbon底层怎样实现不同服务的不同配置" aria-hidden="true">#</a> 拼多多二面——SpringCloud：Ribbon底层怎样实现不同服务的不同配置</h2><h2 id="阿里二面——springcloud-nacos2-x客户端探活机制" tabindex="-1"><a class="header-anchor" href="#阿里二面——springcloud-nacos2-x客户端探活机制" aria-hidden="true">#</a> 阿里二面——SpringCloud：Nacos2.x客户端探活机制？</h2><h2 id="阿里二面——springcloud-nacos配置中心配置优先级" tabindex="-1"><a class="header-anchor" href="#阿里二面——springcloud-nacos配置中心配置优先级" aria-hidden="true">#</a> 阿里二面——SpringCloud：Nacos配置中心配置优先级？</h2><h2 id="美团二面——springcloud-nacos1-x配置中心长轮询机制" tabindex="-1"><a class="header-anchor" href="#美团二面——springcloud-nacos1-x配置中心长轮询机制" aria-hidden="true">#</a> 美团二面——SpringCloud：Nacos1.x配置中心长轮询机制？</h2><h2 id="美团二面——springcloud-配置中心的技术选型" tabindex="-1"><a class="header-anchor" href="#美团二面——springcloud-配置中心的技术选型" aria-hidden="true">#</a> 美团二面——SpringCloud：配置中心的技术选型</h2><h2 id="美团二面——springcloud-nacos中的distro协议" tabindex="-1"><a class="header-anchor" href="#美团二面——springcloud-nacos中的distro协议" aria-hidden="true">#</a> 美团二面——SpringCloud：Nacos中的Distro协议</h2><h2 id="美团二面——springcloud-nacos服务领域模型有哪些" tabindex="-1"><a class="header-anchor" href="#美团二面——springcloud-nacos服务领域模型有哪些" aria-hidden="true">#</a> 美团二面——SpringCloud：Nacos服务领域模型有哪些？</h2><h2 id="阿里二面——springcloud-nacos1-x作为注册中心的原理" tabindex="-1"><a class="header-anchor" href="#阿里二面——springcloud-nacos1-x作为注册中心的原理" aria-hidden="true">#</a> 阿里二面——SpringCloud：Nacos1.x作为注册中心的原理？</h2><h2 id="美团二面——springcloud-如何设计一个注册中心" tabindex="-1"><a class="header-anchor" href="#美团二面——springcloud-如何设计一个注册中心" aria-hidden="true">#</a> 美团二面——SpringCloud：如何设计一个注册中心？</h2><h2 id="阿里二面——spring-谈谈你对循环依赖的理解" tabindex="-1"><a class="header-anchor" href="#阿里二面——spring-谈谈你对循环依赖的理解" aria-hidden="true">#</a> 阿里二面——Spring：谈谈你对循环依赖的理解</h2><h2 id="头条一面——spring-spring中的bean单例对象是否是线程安全的" tabindex="-1"><a class="header-anchor" href="#头条一面——spring-spring中的bean单例对象是否是线程安全的" aria-hidden="true">#</a> 头条一面——Spring：Spring中的Bean单例对象是否是线程安全的</h2><h2 id="头条一面——spring-介绍下spring中的依赖注入" tabindex="-1"><a class="header-anchor" href="#头条一面——spring-介绍下spring中的依赖注入" aria-hidden="true">#</a> 头条一面——Spring：介绍下Spring中的依赖注入</h2><h2 id="头条一面——spring-有哪些通知类型-advice" tabindex="-1"><a class="header-anchor" href="#头条一面——spring-有哪些通知类型-advice" aria-hidden="true">#</a> 头条一面——Spring：有哪些通知类型(Advice)</h2><h2 id="头条一面——spring-component-controller-repository-service-有何区别" tabindex="-1"><a class="header-anchor" href="#头条一面——spring-component-controller-repository-service-有何区别" aria-hidden="true">#</a> 头条一面——Spring：@Component, @Controller, @Repository,@Service 有何区别</h2><h2 id="头条一面——spring-谈谈indexed注解的作用" tabindex="-1"><a class="header-anchor" href="#头条一面——spring-谈谈indexed注解的作用" aria-hidden="true">#</a> 头条一面——Spring：谈谈Indexed注解的作用</h2><h2 id="头条二面——spring-如果要对属性文件中的账号密码加密如何实现" tabindex="-1"><a class="header-anchor" href="#头条二面——spring-如果要对属性文件中的账号密码加密如何实现" aria-hidden="true">#</a> 头条二面——Spring：如果要对属性文件中的账号密码加密如何实现？</h2><h2 id="头条二面——spring-谈谈springboot中的bootstrap-yml文件的作用" tabindex="-1"><a class="header-anchor" href="#头条二面——spring-谈谈springboot中的bootstrap-yml文件的作用" aria-hidden="true">#</a> 头条二面——Spring：谈谈SpringBoot中的bootstrap.yml文件的作用</h2><h2 id="头条二面——spring-谈谈你对deferredimportselector的理解" tabindex="-1"><a class="header-anchor" href="#头条二面——spring-谈谈你对deferredimportselector的理解" aria-hidden="true">#</a> 头条二面——Spring：谈谈你对DeferredImportSelector的理解</h2><h2 id="头条二面——spring-谈谈你对import注解的理解" tabindex="-1"><a class="header-anchor" href="#头条二面——spring-谈谈你对import注解的理解" aria-hidden="true">#</a> 头条二面——Spring：谈谈你对Import注解的理解</h2><h2 id="头条二面——spring-谈谈你对springboot自动装配原理的理解" tabindex="-1"><a class="header-anchor" href="#头条二面——spring-谈谈你对springboot自动装配原理的理解" aria-hidden="true">#</a> 头条二面——Spring：谈谈你对SpringBoot自动装配原理的理解</h2><h2 id="头条二面——spring-谈谈你对delegatingfilterproxy的理解" tabindex="-1"><a class="header-anchor" href="#头条二面——spring-谈谈你对delegatingfilterproxy的理解" aria-hidden="true">#</a> 头条二面——Spring：谈谈你对DelegatingFilterProxy的理解</h2><h2 id="头条二面——spring-谈谈spring和springmvc的关系" tabindex="-1"><a class="header-anchor" href="#头条二面——spring-谈谈spring和springmvc的关系" aria-hidden="true">#</a> 头条二面——Spring：谈谈Spring和SpringMVC的关系</h2><h2 id="头条二面——spring-谈谈你对springmvc框架的理解" tabindex="-1"><a class="header-anchor" href="#头条二面——spring-谈谈你对springmvc框架的理解" aria-hidden="true">#</a> 头条二面——Spring：谈谈你对SpringMVC框架的理解</h2><h2 id="头条二面——spring-谈谈你对beanpostprocessor的理解" tabindex="-1"><a class="header-anchor" href="#头条二面——spring-谈谈你对beanpostprocessor的理解" aria-hidden="true">#</a> 头条二面——Spring：谈谈你对BeanPostProcessor的理解</h2><h2 id="头条二面——spring-谈谈你对beanfactorypostprocessor的理解" tabindex="-1"><a class="header-anchor" href="#头条二面——spring-谈谈你对beanfactorypostprocessor的理解" aria-hidden="true">#</a> 头条二面——Spring：谈谈你对BeanFactoryPostProcessor的理解</h2><h2 id="头条二面——spring-谈谈你对beanfactory和applicationcontext的理解" tabindex="-1"><a class="header-anchor" href="#头条二面——spring-谈谈你对beanfactory和applicationcontext的理解" aria-hidden="true">#</a> 头条二面——Spring：谈谈你对BeanFactory和ApplicationContext的理解</h2><h2 id="头条二面——spring-spring中事务的本质" tabindex="-1"><a class="header-anchor" href="#头条二面——spring-spring中事务的本质" aria-hidden="true">#</a> 头条二面——Spring：Spring中事务的本质</h2><h2 id="头条一面——spring-spring中事务的实现方式" tabindex="-1"><a class="header-anchor" href="#头条一面——spring-spring中事务的实现方式" aria-hidden="true">#</a> 头条一面——Spring：Spring中事务的实现方式</h2><h2 id="头条一面——spring-spring中事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#头条一面——spring-spring中事务的隔离级别" aria-hidden="true">#</a> 头条一面——Spring：Spring中事务的隔离级别</h2><h2 id="头条一面——spring-spring中事务的隔离级别介绍" tabindex="-1"><a class="header-anchor" href="#头条一面——spring-spring中事务的隔离级别介绍" aria-hidden="true">#</a> 头条一面——Spring：Spring中事务的隔离级别介绍</h2><h2 id="头条一面——spring-spring中支持的作用域有几种" tabindex="-1"><a class="header-anchor" href="#头条一面——spring-spring中支持的作用域有几种" aria-hidden="true">#</a> 头条一面——Spring：Spring中支持的作用域有几种</h2><h2 id="头条二面——spring-spring中bean对象的生命周期" tabindex="-1"><a class="header-anchor" href="#头条二面——spring-spring中bean对象的生命周期" aria-hidden="true">#</a> 头条二面——Spring：Spring中Bean对象的生命周期</h2><h2 id="阿里二面——spring-spring中的循环依赖为什么需要三级缓存" tabindex="-1"><a class="header-anchor" href="#阿里二面——spring-spring中的循环依赖为什么需要三级缓存" aria-hidden="true">#</a> 阿里二面——Spring：Spring中的循环依赖为什么需要三级缓存</h2><h2 id="阿里二面——spring-spring中是如何解决构造注入的循环依赖问题的" tabindex="-1"><a class="header-anchor" href="#阿里二面——spring-spring中是如何解决构造注入的循环依赖问题的" aria-hidden="true">#</a> 阿里二面——Spring：Spring中是如何解决构造注入的循环依赖问题的</h2><h2 id="阿里二面——spring-spring中是如何解决循环依赖问题的" tabindex="-1"><a class="header-anchor" href="#阿里二面——spring-spring中是如何解决循环依赖问题的" aria-hidden="true">#</a> 阿里二面——Spring：Spring中是如何解决循环依赖问题的</h2><h2 id="阿里二面——spring-谈谈spring中常用的注解" tabindex="-1"><a class="header-anchor" href="#阿里二面——spring-谈谈spring中常用的注解" aria-hidden="true">#</a> 阿里二面——Spring：谈谈Spring中常用的注解</h2><h2 id="阿里二面——spring-谈谈autowired和resource两个注解的区别" tabindex="-1"><a class="header-anchor" href="#阿里二面——spring-谈谈autowired和resource两个注解的区别" aria-hidden="true">#</a> 阿里二面——Spring：谈谈Autowired和Resource两个注解的区别</h2><h2 id="阿里二面——spring-spring中应用到的设计模式有哪些" tabindex="-1"><a class="header-anchor" href="#阿里二面——spring-spring中应用到的设计模式有哪些" aria-hidden="true">#</a> 阿里二面——Spring：Spring中应用到的设计模式有哪些</h2><h2 id="百度二面——spring-谈谈你对spring的理解" tabindex="-1"><a class="header-anchor" href="#百度二面——spring-谈谈你对spring的理解" aria-hidden="true">#</a> 百度二面——Spring：谈谈你对Spring的理解</h2><h2 id="百度二面——mysql-mysql内部支持缓存查询吗" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-mysql内部支持缓存查询吗" aria-hidden="true">#</a> 百度二面——MySQL：MySQL内部支持缓存查询吗</h2><p>这个看mysql的版本，mysql5.7是支持的，但现在8.0已经把缓存查询功能删除了。 并且 即使是mysql5.7，缓存功能也是默认关闭的。</p><h2 id="百度二面——mysql-说一下-mysql-执行一条查询语句的内部执行过程" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-说一下-mysql-执行一条查询语句的内部执行过程" aria-hidden="true">#</a> 百度二面——MySQL：说一下 MySQL 执行一条查询语句的内部执行过程</h2><p><img src="`+u+`" alt="查询语句执行流程" loading="lazy"></p><p>可以看到， MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong>，</p><ul><li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li><li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li></ul><p>好了，现在我们对 Server 层和存储引擎层有了一个简单认识，接下来，就详细说一条 SQL 查询语句的执行流程，依次看看每一个功能模块的作用。</p><p><strong>第一步：连接器</strong></p><p>如果你在 Linux 操作系统里要使用 MySQL，那你第一步肯定是要先连接 MySQL 服务，然后才能执行 SQL 语句，普遍我们都是使用下面这条命令进行连接：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；</span>
<span class="token comment"># -u 指定用户名，管理员角色名为 root；</span>
<span class="token comment"># -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码</span>
mysql <span class="token parameter variable">-h</span> <span class="token variable">$ip</span> <span class="token parameter variable">-u</span> <span class="token variable">$user</span> <span class="token parameter variable">-p</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的，如果 MySQL 服务并没有启动，则会收到如下的报错：</p><p><img src="`+b+'" alt="img" loading="lazy"></p><p>如果 MySQL 服务正常运行，完成 TCP 连接的建立后，连接器就要开始验证你的用户名和密码，如果用户名或密码不对，就收到一个&quot;Access denied for user&quot;的错误，然后客户端程序结束执行。</p><p><img src="'+g+'" alt="img" loading="lazy"></p><p>如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。</p><p>所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><blockquote><p>如何查看 MySQL 服务被多少个客户端连接了？</p></blockquote><p>如果你想知道当前 MySQL 服务被多少个客户端连接了，你可以执行 <code>show processlist</code> 命令进行查看。</p><p><img src="'+m+`" alt="img" loading="lazy"></p><p>比如上图的显示结果，共有两个用户名为 root 的用户连接了 MySQL 服务，其中 id 为 6 的用户的 Command 列的状态为 <code>Sleep</code> ，这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接，并且空闲的时长是 736 秒（ Time 列）。</p><blockquote><p>空闲连接会一直占用着吗？</p></blockquote><p>当然不是了，MySQL 定义了空闲连接的最大空闲时长，由 <code>wait_timeout</code> 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;wait_timeout&#39;</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">---------------+-------+</span>
<span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------+-------+</span>
<span class="token operator">|</span> wait_timeout  <span class="token operator">|</span> <span class="token number">28800</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------+-------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，我们自己也可以手动断开空闲的连接，使用的是 kill connection + id 的命令。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">kill</span> connection <span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。</p><blockquote><p>MySQL 的连接数有限制吗？</p></blockquote><p>MySQL 服务支持的最大连接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;max_connections&#39;</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">-----------------+-------+</span>
<span class="token operator">|</span> Variable_name   <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-----------------+-------+</span>
<span class="token operator">|</span> max_connections <span class="token operator">|</span> <span class="token number">151</span>   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-----------------+-------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，它们的区别如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 短连接</span>
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

<span class="token comment">// 长连接</span>
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
执行sql
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
断开 mysql 服务（TCP 四次挥手）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。</p><p>但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。</p><h2 id="百度二面——mysql-说说-mysql-的主从复制" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-说说-mysql-的主从复制" aria-hidden="true">#</a> 百度二面——MySQL：说说 MySQL 的主从复制</h2><h2 id="百度二面——mysql-什么是分库分表-什么时候进行分库分表" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-什么是分库分表-什么时候进行分库分表" aria-hidden="true">#</a> 百度二面——MySQL：什么是分库分表 什么时候进行分库分表</h2><h2 id="百度二面——mysql-count-列名-、count-1-和-count-星号-有什么区别" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-count-列名-、count-1-和-count-星号-有什么区别" aria-hidden="true">#</a> 百度二面——MySQL：count(列名)、count(1)和 count(星号)有什么区别</h2><h3 id="count-列名" tabindex="-1"><a class="header-anchor" href="#count-列名" aria-hidden="true">#</a> count(列名)</h3><p>语法：<code>count(column_name)</code></p><p><code>count(列名)</code> 函数返回指定列中非空值的行数。例如，如果我们有一个名为 <code>orders</code> 的表，并且要计算 <code>order_id</code> 列中非空值的总数，则可以使用以下语句</p><h3 id="count-1" tabindex="-1"><a class="header-anchor" href="#count-1" aria-hidden="true">#</a> count(1)</h3><p>语法：<code>count(1)</code></p>`,294),x=n("code",null,"count(1)",-1),q={href:"https://so.csdn.net/so/search?q=%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},v=n("code",null,"orders",-1),M=e('<h3 id="count" tabindex="-1"><a class="header-anchor" href="#count" aria-hidden="true">#</a> count(*)</h3><p>语法：<code>count(*)</code></p><p><code>count(*)</code> 函数是一种特殊的 <code>count()</code> 函数，它用于计算表中的所有行数，无论这些行是否包含空值。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><ul><li><code>count(列名)</code> 函数返回指定列中非空值的行数。</li><li><code>count(1)</code> 函数返回表中的所有行数，无论是否存在空值。</li><li><code>count(*)</code> 函数用于计算表中的所有行数，无论这些行是否包含空值。</li></ul><p>这三种用法都有各自的优缺点。如果你只需要计算特定列的行数，则可以使用 <code>count(列名)</code> 函数。如果你需要计算所有列的行数，则应该使用 <code>count(1)</code> 或 <code>count(*)</code> 函数。另外，由于 <code>count(1)</code> 和 <code>count(*)</code> 函数计算表中所有行的总数，因此它们可能比 <code>count(列名)</code> 函数更慢。在涉及关联查询的情况下，<code>count(列名)</code> 和 <code>count(1)</code> 函数可能会返回不正确的结果，因为它们只考虑指定的列或行。与之相反，<code>count(*)</code> 函数可以正确计算关联查询中的所有行数。</p><h2 id="阿里二面——mysql-mysql线上修改大表结构有哪些风险" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-mysql线上修改大表结构有哪些风险" aria-hidden="true">#</a> 阿里二面——MySQL：MySQL线上修改大表结构有哪些风险</h2><p>在MySQL中，对表进行修改操作时，会自动为这张表加锁，防止其他操作干扰。如果要修改大表，需要执行长时间的锁定操作，这就会导致其他用户无法访问该表，甚至会导致整个系统崩溃。因此，在进行大表结构修改操作前，需要考虑相关的锁定问题。</p><p>解决方案：</p><p>a. 在非高峰期进行修改操作，减少影响；<br> b. 使用在线DDL工具，如pt-online-schema-change，避免锁表问题；</p><h2 id="阿里二面——mysql-mysql的binlog有几种日志格式-分别有什么区别" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-mysql的binlog有几种日志格式-分别有什么区别" aria-hidden="true">#</a> 阿里二面——MySQL：MySQL的binlog有几种日志格式 分别有什么区别</h2><p>MySQL的binlog（二进制日志）是MySQL用于记录数据库的更改操作的一种机制，它记录了数据库中每个被修改的数据的更改情况。MySQL的binlog有三种格式，分别是Statement格式、Row格式和Mixed格式。它们的主要区别在于记录更改操作的方式不同。</p><ol><li><strong>Statement格式：</strong><ul><li>Statement格式是将每个SQL语句记录到binlog中。当执行一条修改数据的SQL语句时，比如INSERT、UPDATE、DELETE，MySQL会将这条SQL语句记录到binlog中，而不是记录具体修改了哪些行。</li><li>优点：相对简单，对于某些简单的SQL语句，记录量小，性能较好。</li><li>缺点：对于一些非确定性的SQL语句，比如UPDATE语句中使用了NOW()函数，可能会导致主从复制不一致；无法记录一些行级别的操作，比如在触发器中的操作。</li></ul></li><li><strong>Row格式：</strong><ul><li>Row格式是将每一行数据的变更记录到binlog中。无论一条SQL语句修改了多少行，都会将每一行的变更记录到binlog中。</li><li>优点：更加精确，可以确保主从数据库的数据一致性；能够记录所有行级别的操作，不会受到SQL语句的影响。</li><li>缺点：对于一些大数据量的表，记录的binlog可能会很大；性能消耗较大，因为需要记录每一行的变更。</li></ul></li><li><strong>Mixed格式：</strong><ul><li>Mixed格式是Statement格式和Row格式的混合使用。MySQL根据具体的情况来选择使用哪种格式。</li><li>优点：综合了Statement格式和Row格式的优点，可以在保证一定性能的同时，确保数据的一致性。</li><li>缺点：相比于单一格式，实现起来更加复杂；可能会出现一些情况下无法选择最佳的格式的情况。</li></ul></li></ol><p>选择binlog格式取决于具体的业务需求和性能要求。通常情况下，Row格式是保证主从复制数据一致性的最佳选择，但在某些情况下，可以考虑使用Mixed格式以综合性能和数据一致性。</p><h2 id="阿里二面——mysql-bin-log与undo-log的区别" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-bin-log与undo-log的区别" aria-hidden="true">#</a> 阿里二面——MySQL：bin log与undo log的区别</h2><p>MySQL中的binlog（二进制日志）和undo log（回滚日志）是两种不同的日志，它们的作用和机制也有所不同。</p><ol><li><strong>binlog（二进制日志）：</strong><ul><li>binlog是MySQL用于记录数据库中的更改操作的一种日志，它记录了对数据库执行的SQL语句或数据行的更改。</li><li>binlog记录的是逻辑操作，即记录的是SQL语句的逻辑内容，比如INSERT、UPDATE、DELETE等操作。</li><li>binlog通常用于数据复制（主从复制）、恢复、数据备份和数据同步等场景。</li><li>binlog是在数据库引擎层之上记录的，与具体的存储引擎无关。</li></ul></li><li><strong>undo log（回滚日志）：</strong><ul><li>undo log是MySQL中用于实现事务的原子性和隔离性的一种日志，它记录了事务执行过程中对数据的修改。</li><li>undo log记录的是物理操作，即记录了事务对数据的具体修改，比如某个数据页上的哪些数据被修改了。</li><li>undo log主要用于实现事务的回滚（rollback）操作，在事务回滚时，可以根据undo log来撤销事务的修改操作。</li><li>undo log是在存储引擎层面实现的，不同的存储引擎可能有不同的undo log实现方式，比如InnoDB存储引擎使用undo log来支持事务的ACID特性。</li></ul></li></ol><p><strong>主要区别：</strong></p><ul><li>目的不同：binlog主要用于数据的复制、备份和同步等场景，而undo log主要用于支持事务的原子性和隔离性。</li><li>记录内容不同：binlog记录的是逻辑操作（SQL语句级别），而undo log记录的是物理操作（数据修改的具体内容）。</li><li>存储位置不同：binlog是在数据库引擎层之上记录的，而undo log是在存储引擎层面实现的。</li><li>使用场景不同：binlog通常用于数据复制、备份和同步，而undo log主要用于事务的回滚操作。</li></ul><p>总的来说，binlog和undo log在MySQL中扮演着不同的角色，分别用于记录不同类型的操作，并支持数据库的不同功能和特性。</p><h2 id="阿里二面——mysql-redo-log与undo-log的持久化策略" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-redo-log与undo-log的持久化策略" aria-hidden="true">#</a> 阿里二面——MySQL：redo log与undo log的持久化策略</h2><h2 id="百度二面——mysql-undo-log、redo-log、-bin-log的作用是什么" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-undo-log、redo-log、-bin-log的作用是什么" aria-hidden="true">#</a> 百度二面——MySQL：undo log、redo log、 bin log的作用是什么</h2><h2 id="百度二面——mysql-介绍一下mysql的体系架构" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-介绍一下mysql的体系架构" aria-hidden="true">#</a> 百度二面——MySQL：介绍一下MySQL的体系架构</h2><h2 id="百度二面——mysql-说一下mysql死锁的原因和处理方法" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-说一下mysql死锁的原因和处理方法" aria-hidden="true">#</a> 百度二面——MySQL：说一下MySQL死锁的原因和处理方法</h2><h2 id="百度二面——mysql-说一下mvcc内部细节" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-说一下mvcc内部细节" aria-hidden="true">#</a> 百度二面——MySQL：说一下MVCC内部细节</h2><h2 id="百度二面——mysql-并发事务会产生哪些问题" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-并发事务会产生哪些问题" aria-hidden="true">#</a> 百度二面——MySQL：并发事务会产生哪些问题</h2><h2 id="滴滴二面——mysql-innodb-的行锁是怎么实现的" tabindex="-1"><a class="header-anchor" href="#滴滴二面——mysql-innodb-的行锁是怎么实现的" aria-hidden="true">#</a> 滴滴二面——MySQL：InnoDB 的行锁是怎么实现的</h2><h2 id="滴滴二面——mysql-请说一下共享锁和排他锁" tabindex="-1"><a class="header-anchor" href="#滴滴二面——mysql-请说一下共享锁和排他锁" aria-hidden="true">#</a> 滴滴二面——MySQL：请说一下共享锁和排他锁</h2><h2 id="滴滴二面——mysql-请说一下数据库锁的种类" tabindex="-1"><a class="header-anchor" href="#滴滴二面——mysql-请说一下数据库锁的种类" aria-hidden="true">#</a> 滴滴二面——MySQL：请说一下数据库锁的种类</h2><h2 id="百度二面——mysql-repeatable-read-解决了幻读问题吗" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-repeatable-read-解决了幻读问题吗" aria-hidden="true">#</a> 百度二面——MySQL：Repeatable Read 解决了幻读问题吗</h2><h2 id="百度二面——mysql-mysql-的可重复读怎么实现的" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-mysql-的可重复读怎么实现的" aria-hidden="true">#</a> 百度二面——MySQL：MySQL 的可重复读怎么实现的</h2><h2 id="百度二面——mysql-介绍一下mysql中事务的特性" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-介绍一下mysql中事务的特性" aria-hidden="true">#</a> 百度二面——MySQL：介绍一下MySQL中事务的特性</h2><h2 id="美团二面——mysql-什么是覆盖索引" tabindex="-1"><a class="header-anchor" href="#美团二面——mysql-什么是覆盖索引" aria-hidden="true">#</a> 美团二面——MySQL：什么是覆盖索引？</h2><h2 id="美团二面——mysql-索引哪些情况下会失效" tabindex="-1"><a class="header-anchor" href="#美团二面——mysql-索引哪些情况下会失效" aria-hidden="true">#</a> 美团二面——MySQL：索引哪些情况下会失效？</h2><h2 id="美团二面——mysql-如何进行join优化" tabindex="-1"><a class="header-anchor" href="#美团二面——mysql-如何进行join优化" aria-hidden="true">#</a> 美团二面——MySQL：如何进行JOIN优化？</h2><h2 id="美团二面——mysql-什么是行溢出" tabindex="-1"><a class="header-anchor" href="#美团二面——mysql-什么是行溢出" aria-hidden="true">#</a> 美团二面——MySQL：什么是行溢出？</h2><h2 id="美团二面——mysql-什么是写失效" tabindex="-1"><a class="header-anchor" href="#美团二面——mysql-什么是写失效" aria-hidden="true">#</a> 美团二面——MySQL：什么是写失效？</h2><h2 id="美团二面——mysql-innodb-io线程相关参数优化了解过吗" tabindex="-1"><a class="header-anchor" href="#美团二面——mysql-innodb-io线程相关参数优化了解过吗" aria-hidden="true">#</a> 美团二面——MySQL：InnoDB IO线程相关参数优化了解过吗</h2><h2 id="美团二面——mysql-innodb日志相关的参数优化了解过吗" tabindex="-1"><a class="header-anchor" href="#美团二面——mysql-innodb日志相关的参数优化了解过吗" aria-hidden="true">#</a> 美团二面——MySQL：InnoDB日志相关的参数优化了解过吗</h2><h2 id="美团二面——mysql-说一下innodb内存相关的参数优化" tabindex="-1"><a class="header-anchor" href="#美团二面——mysql-说一下innodb内存相关的参数优化" aria-hidden="true">#</a> 美团二面——MySQL：说一下InnoDB内存相关的参数优化</h2><h2 id="美团二面——mysql-hash索引有哪些优缺点" tabindex="-1"><a class="header-anchor" href="#美团二面——mysql-hash索引有哪些优缺点" aria-hidden="true">#</a> 美团二面——MySQL：Hash索引有哪些优缺点</h2><h2 id="美团二面——mysql-如何做慢查询优化" tabindex="-1"><a class="header-anchor" href="#美团二面——mysql-如何做慢查询优化" aria-hidden="true">#</a> 美团二面——MySQL：如何做慢查询优化</h2><h2 id="百度二面——mysql-如何进行分页查询优化" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-如何进行分页查询优化" aria-hidden="true">#</a> 百度二面——MySQL：如何进行分页查询优化</h2><h2 id="百度二面——mysql-extra有哪些主要指标-各自的含义是什么" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-extra有哪些主要指标-各自的含义是什么" aria-hidden="true">#</a> 百度二面——MySQL：Extra有哪些主要指标，各自的含义是什么</h2><h2 id="百度二面——mysql-type字段中有哪些常见的值" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-type字段中有哪些常见的值" aria-hidden="true">#</a> 百度二面——MySQL：type字段中有哪些常见的值</h2><h2 id="百度二面——mysql-explain-用过吗-有哪些主要字段" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-explain-用过吗-有哪些主要字段" aria-hidden="true">#</a> 百度二面——MySQL：explain 用过吗，有哪些主要字段</h2><h2 id="百度二面——mysql-一个b-树中大概能存放多少条索引记录" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-一个b-树中大概能存放多少条索引记录" aria-hidden="true">#</a> 百度二面——MySQL：一个B+树中大概能存放多少条索引记录？</h2><h2 id="百度二面——mysql-b树和b-树的区别是什么" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-b树和b-树的区别是什么" aria-hidden="true">#</a> 百度二面——MySQL：B树和B+树的区别是什么</h2><h2 id="百度二面——mysql-innodb与myisam的区别" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-innodb与myisam的区别" aria-hidden="true">#</a> 百度二面——MySQL：InnoDB与MyISAM的区别</h2><h2 id="百度二面——mysql-自增还是uuid-数据库主键的类型该如何选择" tabindex="-1"><a class="header-anchor" href="#百度二面——mysql-自增还是uuid-数据库主键的类型该如何选择" aria-hidden="true">#</a> 百度二面——MySQL：自增还是UUID 数据库主键的类型该如何选择</h2><h2 id="阿里二面——mysql-为什么like以-开头索引会失效" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-为什么like以-开头索引会失效" aria-hidden="true">#</a> 阿里二面——MySQL：为什么LIKE以%开头索引会失效</h2><h2 id="阿里二面——mysql-什么是自适应哈希索引" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-什么是自适应哈希索引" aria-hidden="true">#</a> 阿里二面——MySQL：什么是自适应哈希索引</h2><h2 id="阿里二面——mysql-什么是索引下推" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-什么是索引下推" aria-hidden="true">#</a> 阿里二面——MySQL：什么是索引下推？</h2><h2 id="阿里二面——mysql-介绍一下最佳左前缀法则" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-介绍一下最佳左前缀法则" aria-hidden="true">#</a> 阿里二面——MySQL：介绍一下最佳左前缀法则</h2><h2 id="阿里二面——mysql-索引有哪几种类型" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-索引有哪几种类型" aria-hidden="true">#</a> 阿里二面——MySQL：索引有哪几种类型？</h2><h2 id="阿里二面——mysql-说一下聚簇索引与非聚簇索引" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-说一下聚簇索引与非聚簇索引" aria-hidden="true">#</a> 阿里二面——MySQL：说一下聚簇索引与非聚簇索引</h2><h2 id="阿里二面——mysql-介绍一下page页的结构" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-介绍一下page页的结构" aria-hidden="true">#</a> 阿里二面——MySQL：介绍一下Page页的结构</h2><h2 id="阿里二面——mysql-使用索引一定可以提升效率吗" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-使用索引一定可以提升效率吗" aria-hidden="true">#</a> 阿里二面——MySQL：使用索引一定可以提升效率吗</h2><h2 id="阿里二面——mysql-mysql为什么要改进lru算法" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-mysql为什么要改进lru算法" aria-hidden="true">#</a> 阿里二面——MySQL：MySQL为什么要改进LRU算法？</h2><h2 id="阿里二面——mysql-为什么写缓冲区-仅适用于非唯一普通索引页" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-为什么写缓冲区-仅适用于非唯一普通索引页" aria-hidden="true">#</a> 阿里二面——MySQL：为什么写缓冲区 仅适用于非唯一普通索引页？</h2><h2 id="阿里二面——mysql-innodb引擎如何管理page页" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-innodb引擎如何管理page页" aria-hidden="true">#</a> 阿里二面——MySQL：InnoDB引擎如何管理Page页？</h2><h2 id="阿里二面——mysql-什么是bufferpool" tabindex="-1"><a class="header-anchor" href="#阿里二面——mysql-什么是bufferpool" aria-hidden="true">#</a> 阿里二面——MySQL：什么是BufferPool？</h2>',62);function Q(L,R){const s=t("ExternalLinkIcon");return o(),d("div",null,[y,n("p",null,[a("详情流程见链接："),n("a",f,[a("synchronized 实现原理"),i(s)])]),S,n("p",null,[x,a(" 函数返回表中的所有行数，无论"),n("a",q,[a("是否存在"),i(s)]),a("空值。例如，如果我们要计算表 "),v,a(" 的行数")]),M])}const E=r(k,[["render",Q],["__file","大厂面试题.html.vue"]]);export{E as default};
